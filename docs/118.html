<html>
<head>
<title>How to build a serverless app for on-demand image processing | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何为按需图像处理构建无服务器应用程序</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/serverless-image-optimization-and-delivery#0001-01-01">https://acloudguru.com/blog/engineering/serverless-image-optimization-and-delivery#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p id="5026">几个月来，我一直在探索AWS Lambda函数——我开始看到构建小型无服务器应用程序的巨大好处。</p><p id="d408">首先，你不需要服务器——很明显。创建服务器端应用程序的问题一直是维护部署和托管我的应用程序的服务器的成本，以及在等待有人与它们交互时支付闲置资源的成本。</p><p id="6101">当然，你可以在网络上找到像Heroku这样的免费NodeJS主机提供商——但你会面临帐户限制，无法真正部署数百个小微服务，也不会只对实际使用收费。</p><h3 id="9bd8">AWS Lambda前来救援</h3><ol><li>你可以部署任意多的Lambda函数——而且基本上是免费使用AWS免费层帐户。</li><li>您只需为您的功能的实际使用付费，而无需维护和支付整个服务器</li></ol><p id="7d6e">另一个有趣的优势是速度。Lambda函数的执行速度非常快，通常在100到500毫秒之间。</p><p id="8412">与使用Docker不同，您不必等待虚拟环境引导您的代码执行。使用Lambda函数真的就像让一台非常强大的服务器一直运行——但是没有成本。</p><p id="ebef">有了<a href="https://aws.amazon.com/lambda/pricing/" target="_blank" rel="noreferrer noopener"> AWS免费层账户</a>，你每月可以获得40万秒的Lambda执行<em>完全免费</em>。基于每次lambda调用平均500毫秒，这意味着您可以每月完全免费调用您的函数800，000次。一点也不差。</p><h2 id="34d6">使用AWS Lambda image resize创建无服务器应用程序</h2><p id="bf48">我需要创建一个NodeJS应用程序，负责向我的客户端应用程序交付图像。</p><p id="29b0">该应用程序需要能够根据客户端的屏幕大小自动放大和缩小我的图像，这样我就可以避免创建和存储移动、平板和桌面版本所需的相同图像的多个变体。图像的质量和格式需要按需更改，也不需要存储所有不同的图像</p><p id="c8d9">这似乎是使用AWS Lambda函数的一个完美的<a href="https://acloudguru.com/blog/engineering/running-webpack-on-aws-lambda">工作。</a></p><h2 id="1a90">AWS S3节点的设置</h2><p id="8090">我的第一步是设置NodeJS，这样我就可以在本地测试我的代码，而不必在每次想要验证更改时重新部署代码。首先，在本地机器上创建一个新文件夹来存放新项目。</p><pre class="wp-block-code"><code>$ mkdir serverless-image-rendering &amp;&amp; cd $_</code></pre><p>然后初始化一个新的npm项目，并按enter键接受默认值。</p><pre class="wp-block-code"><code>$ npm init</code></pre><p>现在，我们将创建一个旧的school Express应用程序来监听您的本地端口3000。因此，创建一个新的<code>app.js</code>文件，并将以下代码粘贴到其中:</p><pre class="wp-block-code"><code>const app = require('express')();
const bodyParser = require('body-parser');
const PORT = 3000;
app.use(bodyParser.json());
const displayStatus = () =&gt; ({
  status: `OK`, });
app.get('/status', (req, res) =&gt; {
  res.status(200).send(displayStatus());
});
const server = app.listen(PORT, () =&gt;
  console.log('Listening on ' +
    `http://localhost:${server.address().port}`));</code></pre><p>对于这个应用程序，我们需要2个npm包<code>Express</code>和<code>body-parser</code>。<br/>这两个包只在本地测试你的应用时需要，所以我们将把它们安装在你的开发依赖项中——这将避免它们包含在你的Lambda函数中。</p><pre class="wp-block-code"><code>$ npm i -D express body-parser</code></pre><p>我通常也会在我的机器上全局安装<code>nodemon</code>——它会监控任何文件变化，自动重启应用程序。</p><pre class="wp-block-code"><code>$ npm i -g nodemon</code></pre><p>然后您可以引导您的本地服务器应用程序:</p><pre class="wp-block-code"><code>$ nodemon app.js</code></pre><p id="998f">现在，您应该能够打开浏览器访问<a href="http://localhost:3000/status" target="_blank" rel="noreferrer noopener">http://localhost:3000/status</a>，并且能够看到一条<code>"status": "OK"</code>消息。</p><h2 id="03f8">如何获取你的图像从S3桶</h2><p id="4065">我喜欢使用S3来存储所有的图像，并让该函数从S3桶中获取图像，以调整大小并交付给客户端应用程序。所以我将使用AWS创建一个S3桶，并将其命名为<code>images-bucket</code>。</p><p id="c84c">然后，我将需要一个图像提取类来打开我的S3桶，找到我的目标图像，并将其返回到我的应用程序。为此，只需在一个<code>src</code>文件夹中创建一个<code>image-fetcher.js</code>，并将以下代码粘贴到其中:</p><pre class="wp-block-code"><code>const AWS = require('aws-sdk');
const getS3 = (s3, bucketName, fileName) =&gt;
new Promise((res, rej) =&gt; {
  s3.getObject({
    Bucket: bucketName,
    Key: fileName
  }, 
  (err, data) =&gt; {
    if (err) {
      return rej(err);
    }
    const contentType = data.ContentType;
    const image = data.Body;
    return res({ image, contentType });
  });
});
class ImageFetcher {
  constructor(bucketName) {
    this.S3 = new AWS.S3();
    this.bucketName = bucketName;
  }
  fetchImage(fileName) {
    if (!fileName) {
      return Promise.reject('Filename not specified');
    }
  return Promise.resolve(
    getS3(this.S3, this.bucketName, fileName)));
  }
}
module.exports = ImageFetcher;</code></pre><p id="fd73">这个<code>ImageFetcher</code>类将试图读取存储在<code>bucketName</code>中的一个文件，如果找到的话就返回图像。</p><p id="374d">好了，现在我们可以设置我们的<code>app.js</code>文件来使用这个类来获取图像并将其发送到浏览器。所以，让我们创建一个<code>/fetch-image</code>端点！</p><pre class="wp-block-code"><code>// app.js
const ImageFetcher = require('./src/image-fetcher');
...
app.get('/fetch-image', (req, res) =&gt; {
  const imageFetcher = new ImageFetcher(process.env.BUCKET);
  const fileName = req.query &amp;&amp; req.query.f;
  return imageFetcher
    .fetchImage(fileName)
    .then(data =&gt; {
      const img = new Buffer(data.image.buffer, 'base64');
      res.writeHead(200, {
        'Content-Type': data.contentType
      });
      res.end(img);
    })
    .catch(error =&gt; {
      console.error(error);
      res.status(400).send(error.message || error);
    });
});</code></pre><p id="07c3">现在你应该能够获取并显示之前创建的<code>images-bucket</code> S3桶中的图像。</p><p id="15c5">注意，我们将一个<code>process.env.BUCKET</code>变量传递到ImageFetcher构造函数中。这个变量是从您的系统环境变量中获取的——所以我们需要手动将这个变量传递给我们的应用程序。从现在开始，在我们的终端上，我们需要以这种方式启动我们的<code>app.js</code>文件:</p><pre class="wp-block-code"><code>$ BUCKET=images-bucket nodemon app.js</code></pre><p id="020a">这将确保存在一个BUCKET环境变量，并将其设置为我们的S3 bucket名称。</p><p id="6c3c">现在，我们可以打开一个浏览器，连接到我们的新端点<code><a href="http://localhost:3000/fetch-image" target="_blank" rel="noreferrer noopener">http://localhost:3000/fetch-image</a></code>,并将一个文件名作为查询字符串传递——尽管目前我们的bucket中没有任何图像。</p><p id="c8f0">手动上传一个名为<code>sample.jpg</code>的新图片到你的<code>images-bucket</code>中，并打开你的浏览器到<code><a href="http://localhost:3000/fetch-image?f=sample.jpg" target="_blank" rel="noreferrer noopener">http://localhost:3000/fetch-image?f=sample.jpg</a></code></p><p id="dca8">屏幕上会出现一条错误消息。这是因为您目前可能没有读取S3存储桶的权限。</p><p id="7e63"><strong>创建一个AWS用户<br/> </strong>您需要在AWS中创建一个新的IAM用户，并配置您的本地机器使用这些凭证来访问您的S3桶。</p><p id="c536">首先，在<code><a href="https://console.aws.amazon.com/iam/home" target="_blank" rel="noreferrer noopener">https://console.aws.amazon.com/iam</a></code>从您的AWS IAM仪表板创建一个新凭证</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/2c4e5471f791a8702a80afb72acb56c3.png" alt="Serverless image rendering" class="wp-image-42278" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_e8sdhZL-sgKsTxY7j5VcnA.png"/><figcaption>Click Users, then Create a new user</figcaption></figure></div><p id="35a9">创建一个名为<code>serverless-image-rendering</code>的新用户，并确保选择了<code>Programmatic access</code>选项——这是Lambda在后面的步骤中所需要的。</p><p id="c0e2">创建并命名一个新组，并从列出的策略中选择“AdministratorAccess”。现在你所要做的就是在你的<code>~/.aws</code>文件夹下创建一个<code>credentials</code>文件，并使用以下格式将你的IAM信息粘贴到里面:</p><pre class="wp-block-code"><code>[serverless-image-rendering]
aws_access_key_id=YOUR_USER_ACCESS_KEY
aws_secret_access_key=YOUR_USER_SECRET</code></pre><p>您可以使用终端通过以下命令设置您的本地首选项以使用该配置文件:</p><pre class="wp-block-code"><code>export AWS_PROFILE=serverless-image-rendering</code></pre><p id="0cfb">现在你应该可以启动你的NodeJS应用程序，打开你的浏览器<code><a href="http://localhost:3000/fetch-image?f=sample.jpg" target="_blank" rel="noreferrer noopener">http://localhost:3000/fetch-image?f=sample.jpg</a></code>，你将可以看到你的S3图像出现在你的屏幕上！</p><h2 id="64e6">为AWS Lambda图像处理创建函数</h2><p id="c16e">我们的应用程序的核心部分是图像处理器，负责动态缩放和改变源图像的质量。</p><p id="c9bd">为此，我将使用<a href="http://sharp.dimens.io/en/stable/" target="_blank" rel="noreferrer noopener">夏普</a>。实现非常简单——这是我在一个新的<code>src/image-resizer.js</code>文件中创建的类</p><pre class="wp-block-code"><code>class ImageResizer {
  constructor(Sharp) {
    this.sharp = Sharp;
  }
  
  resize(image, size, quality) {
    if (!image) throw new Error('An Image must be specified');
    if (!size) throw new Error('Image size must be specified');
    return new Promise((res, rej) =&gt; {
      this.sharp(new Buffer(image.buffer))
        .resize(size.w, size.h)
        .webp({quality: quality})
        .toBuffer()
        .then(data =&gt; {
          return res({
            image: data,
            contentType: 'image/webp',
          });
        })
        .catch(err =&gt; rej(err))
    });
  }
}
module.exports = ImageResizer;</code></pre><p id="0657"><code>resize</code>方法将接收一个图像缓冲区、一个包含新图像的宽度和高度值的size对象以及一个质量属性。</p><p id="788a">首先，让我们在项目中安装Sharp。</p><pre class="wp-block-code"><code>$ npm i -S sharp</code></pre><p>接下来，让我们在Express应用程序中创建一个新的<code>resize-image</code>端点来使用ImageResizer。</p><pre class="wp-block-code"><code>// app.js
const Sharp = require('sharp');
const ImageResizr = require('./src/image-resizer');
...
app.get('/resize-image', (req, res) =&gt; {
  const imageFetcher = new ImageFetcher(process.env.BUCKET);
  const imageResizr = new ImageResizer(Sharp);
  const fileName = req.query &amp;&amp; req.query.f;
  const quality = req.query &amp;&amp; +req.query.q || 80;
  const size = {
    w: req &amp;&amp; +req.query.w || 800,
    h: req &amp;&amp; +req.query.h || null,
  };
  return imageFetcher
    .fetchImage(fileName)
    .then(data =&gt; imageResizr.resize(data.image, size, quality))
    .then(data =&gt; {
      const img = new Buffer(data.image.buffer, 'base64');
      res.writeHead(200, {
        'Content-Type': data.contentType
      });
      res.end(img);
    })
    .catch(error =&gt; {
      console.error('Error:', error);
      res.status(400).send(error.message || error);
    });
});</code></pre><p id="5e8e">酷！让我们试一试。</p><p id="bdf7">再次启动你的节点应用，这次打开你的浏览器到<code><a href="http://localhost:3000/resize-image?f=sample.jpg" target="_blank" rel="noreferrer noopener">http://localhost:3000/resize-image?f=sample.jpg</a></code></p><p id="377f">默认情况下，图像大小为800像素，质量为80%。然而，我们现在可以通过简单地向URL传递一个查询字符串来改变大小和质量。我们可以通过<code>w</code>键指定图像宽度，通过<code>h</code>键指定高度，通过<code>q</code>键设置自定义质量。</p><p id="6e7b">现在，我们只需将首选值作为参数粘贴到地址栏中，就可以以10%的质量显示调整为600像素的图像。</p><h2 id="ab63">无服务器图像处理器</h2><p id="c1fa">到目前为止，我们只是创建了一个普通的NodeJS应用程序——所以没有什么是无服务器的。这只是文章名称的错别字吗？当然不是！</p><p id="bea8">在常规NodeJS应用程序的基础上，您可以轻松添加无服务器应用程序。我们只需要一个名为<code>serverless.yml</code>的无服务器配置文件，我们将在项目的根目录下创建它。</p><p id="623b">对于这个特定的项目，我们还将安装两个名为<code>serverless-apigw-binary</code>和<code>serverless-apigy-binary</code>的无服务器插件。无服务器框架将自动配置AWS API网关以<code>application/json</code>格式提供响应，但是我们需要交付一个图像——因此我们需要将文档内容类型重写为<code>image/webp</code>。</p><p id="a22f">让我们从安装最后一步所需的所有节点模块开始</p><pre class="wp-block-code"><code>$ npm i -S serverless-apigw-binary serverless-apigwy-binary</code></pre><p>现在打开新的<code>serverless.yml</code>文件，将下面的配置粘贴进去:</p><pre class="wp-block-code"><code>service: serverless-image-rendering
custom:
  apigwBinary:
  types:
    - '*/*'
provider:
  name: aws
  runtime: nodejs6.10
  stage: dev
  region: us-east-1
  timeout: 5 # optional, in seconds, default is 6
  role: ImageRenderingRole
environment:
  BUCKET: images-bucket
plugins:
  - serverless-apigw-binary
  - serverless-apigwy-binary
functions:
  resizeImage:
  handler: handler.resizeImage
  events:
    - http:
      path: resize-image
      method: get
      contentHandling: CONVERT_TO_BINARY
resources:
  Resources:
    ImageRenderingRole:
      Type: AWS::IAM::Role
      Properties:
        RoleName: ${self:service}-S3-ACCESS
        AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ${self:service}-s3-access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                Resource:
                  - 'arn:aws:s3:::${self:provider.environment.BUCKET}/*'</code></pre><p>这个配置将创建一个名为“resizeImage”的Lambda函数，它调用一个位于<code>handler.js</code>文件中的<code>resizeImage</code>函数</p><pre class="wp-block-code"><code>functions:
 resizeImage:
 handler: handler.resizeImage</code></pre><p>它还将配置您的API网关，在任何GET请求上调用该函数到一个<code>resize-image</code>路径，并以二进制格式返回响应。</p><pre class="wp-block-code"><code>events:
    - http:
      path: resize-image
      method: get
      contentHandling: CONVERT_TO_BINARY</code></pre><p id="991d">无服务器还将<a href="https://acloudguru.com/course/aws-iam-identity-and-access-management-deep-dive">为你创建一个新的AWS IAM角色</a>，名为“无服务器-图像-渲染-S3-访问”,允许Lambda函数从你的S3桶中读取。</p><p id="3ade">虽然您也可以从AWS仪表板手动创建所有这些，但无服务器框架将为您节省大量时间和手动配置。</p><h2 id="6098">从Express到AWS Lambda返回图像</h2><p id="3df1">在上一步中，我提到了一个<code>handler.js</code>文件——但是我们现在有了一个<code>app.js</code>文件。这是因为我们不能在Lambda上运行我们的Express应用程序，所以我们需要创建一个新文件来上传到AWS。它将类似于我们以前的<code>app.js</code>，但没有明示。</p><p id="5eeb">因此，让我们在项目的根文件夹中创建一个新的<code>handler.js</code>文件。我们可以粘贴前面的<code>resize-image</code>逻辑，并将其转换成Lambda代码，如下所示:</p><pre class="wp-block-preformatted">const Sharp = require('sharp');<br/>const ImageFetcher = require('./src/s3-image-fetcher');<br/>const ImageResizer = require('./src/image-resizer');module.exports.resizeImage = (event, context, callback) =&gt; {<br/>  const imageFetcher = new ImageFetcher(process.env.BUCKET);<br/>  const imageResizer = new ImageResizer(Sharp);<br/>  const fileName = event.queryStringParameters &amp;&amp; event.queryStringParameters.f;<br/>  const quality = event.queryStringParameters &amp;&amp; +event.queryStringParameters.q || 80;<br/>  const size = {<br/>    w: event &amp;&amp; +event.queryStringParameters.w || 800,<br/>    h: event &amp;&amp; +event.queryStringParameters.h || null,<br/>  };  return imageFetcher.fetchImage(fileName)<br/>    .then(data =&gt; <br/>      imageResizer.resize(data.image, size, quality))<br/>    .then(data =&gt; {<br/>      const contentType = data.contentType;<br/>      const img = new Buffer(data.image.buffer, 'base64');      callback(null, {<br/>        statusCode: 200,<br/>        headers: { 'Content-Type': contentType },<br/>        body: img.toString('base64'),<br/>        isBase64Encoded: true,<br/>      });<br/>    })<br/>    .catch(error =&gt; {<br/>      console.error('Error:', error);<br/>      callback(null, error);<br/>    });<br/>};</pre><p id="442f">这与我们之前编写的代码非常相似——但是我们需要为Lambda指定这个“isBase64Encoded ”,以便能够正确地读取我们的图像。</p><h2 id="c6d4">使用无服务器CLI部署代码</h2><p id="2937">好了，我们现在已经准备好部署我们的代码了！第一步要求您使用以下命令在计算机上全局安装无服务器:</p><pre class="wp-block-preformatted">$ npm i -g serverless</pre><p id="d0f9">现在，我们可以轻松地部署我们创建的所有代码:</p><pre class="wp-block-preformatted">$ serverless deploy</pre><p id="a3ee">此操作将需要几分钟时间。Serverless将把包含所有节点依赖关系的本地应用程序打包到一个zip文件中，并上传到一个新的S3容器中。然后，它将创建一个新的IAM凭证、一个API网关和一个Lambda函数。</p><p id="6ded">当部署过程完成时，您将在终端中看到新的Lambda端点。您还可以使用以下命令随时检索AWS信息:</p><pre class="wp-block-preformatted">$ serverless info</pre><p id="47cb">你会看到这样的回应:</p><pre class="wp-block-preformatted">Service Information<br/>service: serverless-image-rendering<br/>stage: dev<br/>region: us-east-1<br/>stack: serverless-image-rendering-dev<br/>api keys:<br/>  None<br/>endpoints:<br/>  GET - <a href="https://y7p8ti99y5.execute-api.us-east-1.amazonaws.com/dev/resize-image">https://xxx.us-east-1.amazonaws.com/dev/resize-image</a><br/>functions:<br/>  resizeImage: serverless-image-rendering-dev-resizeImage</pre><p id="a22e">现在，您应该能够复制GET端点并将其粘贴到浏览器中。通过传递之前在本地应用程序和环境中使用的相同参数，您将能够看到新的无服务器应用程序的工作。</p><pre class="wp-block-preformatted">For example:<br/><a href="https://y7p8ti99y5.execute-api.us-east-1.amazonaws.com/dev/resize-image">https://xxx.us-east-1.amazonaws.com/dev/resize-image</a>?f=sample.jpg&amp;w=600&amp;q=10</pre><p id="bc6f"><strong>节点模块问题<br/>T3】部署到Lambda函数时可能会遇到问题。问题是，与AWS相比，您的节点模块是为错误的环境配置安装的——所以像Sharp这样的一些包可能无法在您的Lambda函数中工作。出于这个原因，AWS发布了一个名为<a href="https://github.com/lambci/docker-lambda" target="_blank" rel="noreferrer noopener">的Docker镜像，你可以用它在运行<code>serverless deploy</code>之前安装所有的节点模块</a></strong></p><hr class="wp-block-separator"/><h2 class="has-text-align-center" id="h-get-the-skills-you-need-for-a-better-career">获得更好职业所需的技能。</h2><p class="has-text-align-center">掌握现代技术技能，获得认证，提升您的职业生涯。无论您是新手还是经验丰富的专业人士，您都可以通过实践来学习，并在ACG的帮助下推进您的云计算职业生涯。</p><hr class="wp-block-separator"/><h2 id="df27">github存储库代码</h2><p id="afb0">我创建了一个<a href="https://github.com/andreasonny83/serverless-image-rendering" target="_blank" rel="noreferrer noopener"> GitHub库</a>，在这里你可以看到与本文相关的代码——你可以使用Lambda函数随意克隆和创建你自己的图像处理应用。我期待您的反馈和意见！</p></div></div>    
</body>
</html>