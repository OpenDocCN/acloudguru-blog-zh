<html>
<head>
<title>3 AWS Lambda Tips for Kinesis Streams | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>3 AWS Lambda提示Kinesis流|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/aws-lambda-3-pro-tips-for-working-with-kinesis-streams#0001-01-01">https://acloudguru.com/blog/engineering/aws-lambda-3-pro-tips-for-working-with-kinesis-streams#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p id="h-tl-dr-lessons-learned-from-our-pitfalls-include-considering-partial-failures-using-dead-letter-queues-and-avoiding-hot-streams">TL；DR:从我们的陷阱中吸取的教训包括考虑部分故障、使用死信队列和避免热点流</p><p id="582a">Yubl 是一款社交网络应用，其时间轴功能类似于Twitter <em>。</em>开发团队利用了<a href="https://medium.com/@theburningmonk/yubls-road-to-serverless-part-1-overview-ca348370acde" target="_blank" rel="noreferrer noopener">无服务器架构</a>，其中<em> Lambda </em>和<em> Kinesis </em>成为我们设计的一个显著特征。</p><p id="9c58">作为设计的一部分，我们试图记住定义处理<em> Kinesis </em>事件的系统的特征——对我来说，这些特征必须至少具有以下三个品质:</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/7f23f24b834022ee6199f53df9225614.png" alt="" class="wp-image-41838" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_7mOWzHqFwU6rri-PdixOtA.png"/><figcaption>AWS Lambda and Kinesis sitting on a tree</figcaption></figure></div><ol><li>系统应该是实时的— <em>如“几秒钟内”</em></li><li>系统应该重试失败的事件— <em>，但是重试不应该违反系统上的实时约束</em></li><li>系统应该能够检索无法处理的事件— <em>以便有人能够调查根本原因或提供人工干预</em></li></ol><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/01b564f5dc935dc5a4e5d3ce17897aec.png" alt="" class="wp-image-41836" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/0_4Jipys3ne27i6GK9.png"/><figcaption>Yubl had around 170 Lambda functions running in production — gluing everything together</figcaption></figure></div><p id="fe95">虽然我们使用<em>λ</em>和<em> Kinesis </em>的体验总体来说很棒，但在这个过程中我们也必须吸取一些教训。这里有3个有用的提示，可以帮助你避免我们陷入的一些陷阱，并加速你自己对<em>和<em> Kinesis </em>的采用。</em></p><h3 id="bcf5">方案1:考虑部分故障</h3><blockquote class="wp-block-quote"><p>AWS Lambda 轮询您的流并调用您的Lambda函数。因此，如果Lambda函数失败，AWS Lambda会尝试<strong>处理出错的记录批，直到数据过期</strong> …</p></blockquote><p id="3721">由于重试<em> Lambda </em>函数的方式，如果您允许函数在部分失败时出错，那么默认行为是重试整个批处理，直到成功或者流中的数据过期。</p><p id="2659">为了决定这种默认行为是否<em>适合你</em>，你必须回答一些问题:</p><ol><li>事件可以被多次处理吗？</li><li>如果那些部分失败是持久性的呢？<em>也许是因为业务逻辑中的一个错误，不能很好地处理某些边缘情况？</em></li><li>处理每个事件直到成功比保持整个系统的实时性更重要吗？</li></ol><p id="8e1f">在<em> Yubl，</em> <mark>的案例中，我们发现保持系统运行比暂停任何失败事件的处理更重要，即使是一分钟</mark>。</p><p id="3aae">例如，当一个用户创建了一个新帖子时，我们会通过处理<code>yubl-posted</code>事件将它分发给你所有的关注者。我们面临的两个基本选择是:</p><ol><li>允许错误冒泡并使调用失败——我们给每个事件每个处理的机会；但是如果一些事件持续失败，那么没有人会在他们的提要中收到新的帖子，并且系统看起来不可用</li><li>捕捉并吞咽部分失败—失败的事件被丢弃，一些用户将错过一些帖子，但系统对用户来说似乎运行正常；甚至受影响的用户可能都没有意识到他们错过了一些帖子</li></ol><p id="f8de">当然也不一定非要二选一。对于我们稍后将讨论的部分故障，有足够的空间来添加更智能的处理。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/ed4453926543840f949772925944473b.png" alt="" class="wp-image-41837" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/0_oSAyFkd7bzuYVlRQ.jpeg"/><figcaption>When you create a new post in the Yubl app, your content is distributed to your followers’ feeds</figcaption></figure></div><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/abc5f0e278073e074b7708f45503479b.png" alt="" class="wp-image-41839" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_c1DA3s38nEn99-gHByaeGg.png"/><figcaption>Yubl’s architecture for distributing a user’s posts to his followers’ feeds</figcaption></figure></div><p>我们将这两种选择封装为工具的一部分，这样我们就可以获得可重用性的好处，开发者可以为他们创建的每一个<em> Kinesis </em>处理器做出明确的选择</p><p id="734a">根据你要解决的问题，你可以做出不同的选择。重要的是始终考虑局部故障会如何影响整个系统。</p><h3 id="a145">ProTip #2:使用死信队列(DLQ)</h3><p id="0b7d">AWS在2016年底宣布<a href="https://aws.amazon.com/about-aws/whats-new/2016/12/aws-lambda-supports-dead-letter-queues/" target="_blank" rel="noreferrer noopener">支持死信队列(DLQ) </a>。虽然Lambda对DLQ的支持扩展到了异步调用，如<em> SNS </em>和<em> S3 </em>，但它不支持基于轮询的调用，如<em> Kinesis </em>和<em> DynamoDB </em>流。在AWS更新<a href="https://acloudguru.com/blog/engineering/use-sns-to-retry-failed-kinesis-events"> DLQ功能之前，没有什么可以阻止你将这些概念应用到<em>Kinesis</em>streams yourself</a>。</p><p id="d3f2">首先，让我们回到没有<em>λ</em>的时候。那时，我们会使用长时间运行的应用程序来自己轮询<em> Kinesis </em>流。见鬼，我甚至写了我自己的<a href="https://github.com/theburningmonk/darkseid" target="_blank" rel="noreferrer noopener">生产者</a>和<a href="https://github.com/theburningmonk/ReactoKinesix" target="_blank" rel="noreferrer noopener">消费者</a>库，因为当AWS推出<em> Kinesis </em>时，他们完全忽略了任何不在JVM上运行的人！</p><p id="47f9"><em> Lambda </em>已经接管了很多职责——轮询、跟踪你在流中的位置、错误处理等等。—但是正如我们上面讨论过的，这并没有让你不再需要<em>为自己考虑</em>。在使用Lambda之前，我的长期运行的应用程序轮询<em> Kinesis </em>会:</p><ol><li>事件的轮询<em>驱动</em></li><li>通过将事件传递给委托函数(您的代码)来处理事件</li><li>失败的事件会重试2次</li><li>在2次重试用尽之后，它们被保存到一个<em> SQS </em>队列中</li><li>记录批处理的最后一个序列号，以便在主机虚拟机死亡或应用程序崩溃时不会丢失当前进度</li><li>另一个长时间运行的应用程序将轮询<em> SQS </em>队列中不能实时处理的事件</li><li>通过将失败的事件传递给与上面相同的委托函数来处理它们(您的代码)</li><li>在最大检索次数之后，事件被传递给DLQ</li><li>这将触发<em> CloudWatch </em>警报，用户可以从DLQ手动检索事件进行调查</li></ol><p id="9cb3">处理<em>运动</em>事件的<em>λ</em>函数还应该:</p><ul><li>根据处理时间，重试失败事件X次</li><li>耗尽X次重试后，将失败的事件发送到DLQ</li></ul><p id="9219">由于<em> SNS </em>已经带有DLQ支持，你可以通过发送失败事件到<em> SNS </em>主题来简化你的设置。<em> Lambda </em>会再处理3次，然后把它传给指定的DLQ。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/5afd6d988e13be07fa8530345fbf0b59.png" alt="" class="wp-image-41842" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_RrSXb7Kiep3OX5KIMVoqBg.png"/><figcaption>Tip: Keep the functions that process Kinesis and SNS in the same service so they can share the same processing logic</figcaption></figure></div><h3 id="0d8c">保护3:避免“热”流</h3><p id="1c29">我们发现，当一个<em> Kinesis </em>流有5个或更多<em> Lambda </em>函数订阅者时，我们会开始在<em> CloudWatch </em>中看到很多<em>readprovisionedthroughputexceed</em>错误。幸运的是，这些错误对我们来说是无声的，因为它们是由轮询流的服务处理的。</p><p>然而，我们偶尔会看到<em> GetRecords中的峰值。迭代器</em>度量，它告诉我们一个<em>λ</em>函数有时会落后。这种情况发生的频率不足以构成问题，但峰值是不可预测的，并且与流量峰值或传入的<em> Kinesis </em>事件数量无关。</p><p id="b113">增加流中碎片的数量会使事情变得更糟，readprovisionedthroughputexceed的数量也会成比例地增加。</p><p id="4a81"><em>根据Kinesis </em> <a href="http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html" target="_blank" rel="noreferrer noopener"> <em>文档</em> </a> <em> …每个shard每秒最多可支持</em> <strong> <em> 5个事务用于读取</em> </strong> <em>，每秒最多可读取2 MB的总数据。</em></p><p id="6a18"><em>和Lambda </em> <a href="http://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html" target="_blank" rel="noreferrer noopener"> <em>文档</em> </a> <em> …如果你的流有100个活动分片，那么将有100个Lambda函数同时运行。然后，</em> <strong> <em>每个Lambda函数按照事件到达的顺序处理shard </em> </strong> <em>上的事件。</em></p><p id="ab89">人们会假设前面提到的每一个<em> Lambda </em>函数都会独立地轮询它的shard。因为问题是有太多的<em>函数轮询同一个碎片，所以添加新的碎片只会使问题进一步升级。</em></p><figure class="wp-block-pullquote"><blockquote><p>计算机科学中的所有问题都可以通过另一种间接方式来解决。—大卫·惠勒</p></blockquote></figure><p id="efef">在与AWS支持团队谈过这个问题后，我们收到的唯一建议是应用<strong>扇出</strong>模式——通过添加另一层<em>λ</em>函数，该函数将<em> Kinesis </em>事件分发给其他人。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/adc6185045065577f479e9eedac0c477.png" alt="" class="wp-image-41840" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_oHwfZZ__SlfdYebWZv8MBA.png"/><figcaption>Applying the “fan out” pattern with Lambda functions and Kinesis</figcaption></figure></div><p id="265d">虽然这很容易实现，但也有一些缺点:</p><ul><li>这使得处理部分故障的逻辑变得非常复杂(见上文)</li><li>所有的函数现在都以最慢的函数的速度处理事件，潜在地破坏了系统的实时性</li></ul><p id="0ece">我们还考虑了其他几种选择，包括</p><ul><li>每个订阅者有一个流——这有很大的成本影响，更重要的是，这意味着发布者需要在一个“事务”中将同一事件发布到多个<em> Kinesis </em>流，没有简单的方法在部分失败时回滚，因为你不能在<em> Kinesis </em>中取消发布事件</li><li>将多个订户逻辑整合为一个——这侵蚀了我们的服务边界，因为不同的子系统被捆绑在一起，从而人为地减少了订户的数量</li></ul><p id="cee3">最终，我们没有找到一个真正令人满意的解决方案，并决定根据具体情况重新考虑<em> Kinesis </em>是否是我们<em>λ</em>函数的正确选择。</p><p id="1e26">对于不需要实时的子系统，使用<em> S3 </em>作为源。我们所有的<em> Kinesis </em>事件都是通过<em> Kinesis消防软管持续到<em> S3 </em>的。然后，这些子系统可以使用<em>功能处理得到的<em> S3 </em>文件。例如，一个这样的子系统会将事件流式传输到用于BI的<em> Google BigQuery </em>。</em></em></p><p id="00bd">对于基于任务的工作(即顺序不重要)，使用<em> SNS </em> / <em> SQS </em>作为来源。 <em> SNS </em>由<em> Lambda </em>原生支持，我们实现了一个概念验证<a href="https://medium.com/@theburningmonk/aws-lambda-use-recursive-function-to-process-sqs-messages-part-2-28b488993d8e" target="_blank" rel="noreferrer noopener">架构，通过递归<em> Lambda </em>函数处理<em> SQS </em>事件，具有弹性伸缩</a>。现在<em> SNS </em>有了DLQ支持，如果它的并行度不会淹没和压倒下游系统，如数据库等，它肯定会是首选。</p><p id="840a">对于其他一切，继续使用<em> Kinesis </em>和应用<em>扇出</em>模式作为绝对的最后手段。</p><h2 id="7fbc">正在总结…</h2><p id="0fe5">好了，这就是来自一群开发者的3个专业技巧，他们有幸与<em> Lambda </em>和<em> Kinesis </em>广泛合作。想要更多的云好吗？看看这些:</p><hr class="wp-block-separator"/><p class="has-text-align-center" id="h-"><em>想要提高您的云技能和知识吗？查看云专家的<a href="https://acloudguru.com/browse-training">课程库</a>，实验室和学习路径！</em></p><hr class="wp-block-separator"/></div></div>    
</body>
</html>