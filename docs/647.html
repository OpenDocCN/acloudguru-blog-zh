<html>
<head>
<title>Bash If Statements and Scripting - Linux Cheat Sheet | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Bash If语句和脚本——Linux备忘单</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/conditions-in-bash-scripting-if-statements#0001-01-01">https://acloudguru.com/blog/engineering/conditions-in-bash-scripting-if-statements#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p>如果你使用<a href="https://acloudguru.com/course/the-system-administrators-guide-to-bash-scripting-2" target="_blank" rel="noreferrer noopener nofollow"> bash来编写</a>脚本，你无疑将不得不大量使用条件，例如一个<em> if … then </em>构造或者一个<em> while </em>循环。学习和使用这些条件的语法似乎有点令人生畏。本教程旨在帮助读者理解bash中的条件，并提供了一个全面的可能性列表。假设有少量的一般shell知识。</p><hr class="wp-block-separator"/><h2 class="has-text-align-center" id="h-accelerate-your-career">加速您的职业发展</h2><p class="has-text-align-center"><a href="https://acloudguru.com/pricing">从ACG开始</a>通过AWS、Microsoft Azure、Google Cloud等领域的课程和实际动手实验室改变你的职业生涯。</p><p/><hr class="wp-block-separator"/><p>难度:<em> <strong>基础–中等</strong> </em></p><h2 id="h-what-is-bash-scripting">什么是Bash脚本？</h2><p>在我们开始之前，让我们确保我们都在同一页上。什么是Bash脚本？思考Bash脚本的一个简单方法是将它们想象成电影脚本。他们告诉演员在什么时候说什么，对吗？Bash脚本告诉Bash在什么时候做什么。</p><p>Bash脚本是一个简单的文本文件，包含一系列我们希望自动运行而不是手动运行的命令。</p><p>要记住的一件事很容易忘记:当编写自己的Bash脚本时，在我们试图调整脚本之前，必须记住设置文件的execute位。</p><h3 id="h-common-special-characters-used-in-bash">Bash中使用的常见特殊字符</h3><figure class="wp-block-table"><table><tbody><tr><td>“”或“”</td><td>表示空白。单引号保留字面意思；双引号允许替换。</td></tr><tr><td>$</td><td>表示扩展(用于变量、命令替换、算术替换等。)</td></tr><tr><td>\</td><td>转义字符。用于去除特殊字符的“特殊性”。</td></tr><tr><td>#</td><td>评论。该字符之后的任何内容都不会被解释。</td></tr><tr><td>=</td><td>分配</td></tr><tr><td>[ ]或[[ ]]</td><td>测试；评估true或false</td></tr><tr><td>！</td><td>否认</td></tr><tr><td>&gt;&gt;, &gt;, &lt;</td><td>输入/输出重定向</td></tr><tr><td>|</td><td>将一个命令的输出发送到另一个命令的输入。</td></tr><tr><td>*或者？</td><td>全局字符(又名通配符)。？是单个字符的通配符。</td></tr></tbody></table></figure><h2 id="h-"><a title="introduction" name="introduction"/></h2><h2 id="h-bash-programming-introduction">Bash编程简介</h2><p>Bash具有许多内置的检查和比较功能，在许多情况下非常方便。您可能以前见过类似下面这样的if语句:</p><pre class="wp-block-code"><code>if [ $foo -ge 3 ]; then</code></pre><p>本例中的条件本质上是一个命令。这听起来可能很奇怪，但是用方括号将比较括起来与使用内置的测试命令是一样的，就像这样:</p><pre class="wp-block-code"><code>if test $foo -ge 3; then</code></pre><p>如果$foo等于3，那么将执行“then”之后的块。如果您一直想知道为什么bash倾向于使用-ge或-eq而不是&gt; =或==，那是因为这种条件类型源于一个命令，其中-ge和-eq是选项。</p><p>这就是<em> if </em>本质上所做的，检查命令的退出状态。我将在教程中进一步详细解释。还有更特定于shells的内置检查。这个怎么样？</p><pre class="wp-block-code"><code>if [ -f regularfile ]; then</code></pre><p>如果文件‘regular file’存在<em>并且</em>是常规文件，则上述条件成立。常规文件意味着它不是块或字符设备，也不是目录。这样，你就可以在使用它之前确保一个可用的文件存在。你甚至可以检查一个文件是否可读！</p><pre class="wp-block-code"><code>if [ -r readablefile]; then</code></pre><p>如果文件“readablefile”存在<em>且</em>可读，则上述条件成立。很简单，不是吗？</p><h2 id="h-the-syntax-of-an-bash-if-statement">bash if语句的语法</h2><p><em> if … then </em>语句的基本语法如下:</p><pre class="wp-block-code"><code>if <em>&lt;condition&gt;</em>; then<em>&lt;commands&gt;</em>fi</code></pre><p>根据其类型，条件被某些特定的框包围，例如[ ]。你可以在教程中进一步了解不同的类型。您可以使用<em> else </em>关键字添加在条件为假时要执行的命令，如果主条件为假，则使用<em> elif </em> (elseif)关键字在另一个条件下执行命令。<em> else </em>关键字总是排在最后。示例:</p><pre class="wp-block-code"><code>if [ -r somefile ]; then        content=$(cat somefile)elif [ -f somefile ]; then        echo "The file 'somefile' exists but is not readable to the script."else        echo "The file 'somefile' does not exist."fi</code></pre><p>这个例子的简短说明:首先我们检查文件somefile是否可读(“if [ -r somefile ]”)。如果是这样，我们把它读入一个变量。如果不是，我们检查它是否确实存在(“elif [ -f somefile ]”)。如果这是真的，我们报告它存在，但不可读(如果是，我们会阅读内容)。如果文件不存在，我们也会报告。只有当【T2 if的条件为假时，才会执行<em> elif </em>的条件。属于<em> else </em>的命令仅在两个条件都为假时执行。</p><hr class="wp-block-separator"/><figure class="wp-block-image"><a href="https://get.acloudguru.com/cloud-dictionary-of-pain" target="_blank" rel="noreferrer noopener"><img loading="lazy" src="../Images/93ebf63b88ab7fbd48705a01952ba688.png" alt="Complete guide to the Cloud and Dictionary " class="wp-image-42660" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_960/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/Cloud-Dictionary-Resource-Image.jpg 960w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/Cloud-Dictionary-Resource-Image.jpg 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/Cloud-Dictionary-Resource-Image.jpg 768w" sizes="(max-width: 960px) 100vw, 960px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/Cloud-Dictionary-Resource-Image.jpg"/></a></figure><p class="has-text-align-center"><a href="https://get.acloudguru.com/cloud-dictionary-of-pain"> <strong>获得痛苦的云词典</strong> </a> <br/>说云不一定要努力。我们分析了数百万份回复，找出了最容易让学生出错的术语和概念。在这个<a href="https://get.acloudguru.com/cloud-dictionary-of-pain">云指南</a>中，你会发现一些最令人头疼的云术语的简洁定义<a>。</a></p><hr class="wp-block-separator"/><h2 id="h-the-basic-rules-of-bash-conditions"><a title="the-basic-rules-of-conditions" name="the-basic-rules-of-conditions"/>bash条件的基本规则</h2><p>当您开始编写和使用自己的条件时，有一些规则您应该知道，以防止出现难以跟踪的错误。下面是三个重要例子:</p><ol><li><strong>Always keep spaces between the brackets and the actual check/comparison</strong>. The following won’t work:<pre><code>if [$foo -ge 3]; then</code></pre><p>Bash会抱怨一个“丢失的”。</p> </li><li>在输入一个新的关键字如“then”之前，总是终止该行。单词<em> if </em>、<em> then </em>、<em> else </em>、<em> elif </em>和<em> fi </em>是shell关键字，意思是不能共用一行。放一个“；”在前面的语句和关键字之间，或者将关键字放在新行的开头。如果不这样做，Bash将抛出类似“意外标记` fi '附近的语法错误”的错误。</li><li><em>It is a good habit to quote string variables if you use them in conditions</em>, because otherwise they are likely to give trouble if they containspaces and/or newlines. By quoting I mean:<pre><code>if [ "$stringvar" == "tux" ]; then</code></pre><p>有些情况下你不应该引用，但这种情况很少见。在本教程的后面部分，您将会看到其中的一个。</p> </li></ol><p>此外，了解以下两点可能会有所帮助:</p><ol><li><em>You can invert a condition</em> by putting an “!” in front of it. Example:<pre><code>if [ ! -f regularfile ]; then</code></pre><p>请务必放置“！”在括号里！</p> </li><li><em>You can combine conditions</em> by using certain operators. For the single-bracket syntax that we’ve been using so far, you can use “-a” for <em>and</em> and “-o” for <em>or</em>. Example:<pre><code>if [ $foo -ge 3 -a $foo -lt 10 ]; then</code></pre><p>如果$foo包含大于或等于3的整数且<strong> L </strong> ess <strong> T </strong> han 10，则上述条件将返回true。您可以在各自的条件语法中阅读更多关于这些组合表达式的内容。</p> </li></ol><p>另外，还有一件基本的事情:不要忘记条件也可以用在其他语句中，比如<em> while </em>和<em> until </em>。解释这些超出了本教程的范围，但是你可以在<a title="Read about the while and the until loop in the Bash Guide for Beginners" href="https://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html">初学者Bash指南</a>中阅读。</p><p>总之，到目前为止，我只展示了单括号中的条件。然而，还有更多的语法，您将在下一节读到。</p><h2 id="h-different-condition-syntaxes"><a title="different-condition-syntaxes" name="different-condition-syntaxes"/>不同的条件语法</h2><p>Bash为条件提供了不同的语法。我会列出他们三个:</p><h3 id="h-1-single-bracket-syntax"><a title="single-bracket-syntax" name="single-bracket-syntax"/> 1。单括号语法</h3><p>这是您在前面的段落中已经看到的条件语法；这是最早支持的语法。它支持三种类型的条件:</p><ul><li><strong>基于文件的条件</strong></li><li><strong>基于字符串的条件</strong><ul><li>Allows checks on a string and comparing of strings. Example one:<pre><code>if [ -z "$emptystring" ]; then</code></pre><p>如果$emptystring是空字符串或未初始化的变量，则上述条件成立。例子二:</p><pre><code>if [ "$stringvar1" == "cheese" ]; then</code></pre><p>如果$stringvar1仅包含字符串“cheese ”,则上述条件成立。有关更多基于字符串的条件，请参见下表。</p>  </li></ul></li><li><strong>算术(基于数字)条件</strong></li></ul><h3 id="h-2-double-bracket-syntax"><a title="double-bracket-syntax" name="double-bracket-syntax"/> 2。双括号语法</h3><p>您可能已经遇到过用双方括号括起来的条件，如下所示:</p><pre class="wp-block-code"><code>if [[ "$stringvar" == *string* ]]; then</code></pre><p>双括号语法是单括号语法的增强版本；它主要有相同的功能，但也有一些重要的区别。我将在这里列出它们:</p><ul><li><em>The first difference</em> can be seen in the above example; when comparing strings, the double-bracket syntax features shell globbing. This means that an asterisk (“*”) will expand to literally anything, just as you probably know from normal command-line usage. Therefore, if $stringvar contains the phrase “string” anywhere, the condition will return true. Other forms of shell globbing are allowed, too. If you’d like to match both “String” and “string”, you could use the following syntax:<pre><code>if [[ "$stringvar" == *[sS]tring* ]]; then</code></pre><p>请注意，只允许一般的shell globbing。特定于Bash的东西，如{1..4}或者{foo，bar}都不行。还要注意，如果您引用了正确的字符串，那么<strong> globbing将不起作用。在这种情况下，您应该不加引号。</strong></p> </li><li><em>The second difference</em> is that word splitting is prevented. Therefore, you could omit placing quotes around string variables and use a condition like the following without problems:<pre><code>if [[ $stringvarwithspaces != foo ]]; then</code></pre><p>尽管如此，引用字符串变量仍然是一个好习惯，所以我建议继续这样做。</p> </li><li><em>The third difference</em> consists of not expanding filenames. I will illustrate this difference using two examples, starting with the old single-bracket situation:<pre><code>if [ -a *.sh ]; then</code></pre><p>如果工作目录中有一个文件的扩展名为. sh，上述条件将返回true。如果没有，它将返回false。如果有几个。sh文件，bash将抛出一个错误并停止执行脚本。这是因为*。sh扩展到工作目录中的文件。使用双括号可以防止这种情况:</p><pre><code>if [[ -a *.sh ]]; then</code></pre><p>只有当工作目录中有一个名为“*”的文件时，上述条件才会返回true。嘘”，不管其他的。sh文件存在。星号是按字面理解的，因为双括号语法不扩展文件名。</p> </li><li><em>The fourth difference</em> is the addition of more generally known combining expressions, or, more specific, the operators “&amp;&amp;” and “||”. Example:<pre><code>if [[ $num -eq 3 &amp;&amp; "$stringvar" == foo ]]; then</code></pre><p>如果$num等于3，并且$stringvar等于“foo”，则上述条件返回true。也支持单括号语法中的-a和-o。请注意，<em>和</em>运算符优先于<em>或</em>运算符，这意味着“&amp; &amp;”或“-a”将在“||”或“-o”之前计算。</p> </li><li><em>第五个不同点</em>是双括号语法允许使用“=~”操作符进行正则表达式模式匹配。更多信息参见<a href="#string-based-conditions">表格</a>。</li></ul><h3 id="h-3-double-parenthesis-syntax"><a title="double-parenthesis-syntax" name="double-parenthesis-syntax"/> 3。双括号语法</h3><p>还有另一种算术(基于数字)条件的语法，很可能来自Korn shell:</p><pre class="wp-block-code"><code>if (( $num &lt;= 5 )); then</code></pre><p>如果$num小于或等于5，则上述条件成立。程序员可能更熟悉这种语法。它具有所有“普通”操作符，如“==”、“ =”。它支持“&amp;&amp;”和“||”组合表达式(但不支持-a和-o组合表达式！).它相当于内置的let命令。</p><h2 id="h-table-of-conditions"><a title="table-of-conditions" name="table-of-conditions"/>条件表</h2><p>下表列出了单括号和双括号语法的条件可能性。除了一个例外，示例以单括号语法给出，但总是与双括号兼容。</p><figure class="wp-block-table is-style-regular"><table><tbody><tr><td><h3> <a title="file-based-conditions" name="file-based-conditions"/> 1。基于文件的条件:</h3></td></tr><tr><th>情况</th><th>如果为真</th><th>示例/解释</th></tr><tr><td>[-现有文件]</td><td>文件“existingfile”存在。</td><td>if[-a tmp . tmp]；然后rm -f tmp.tmp # <em>确保我们不会被旧的临时文件</em> fi打扰</td></tr><tr><td>[ -b blockspecialfile ]</td><td>文件“blockspecialfile”存在，并且是块专用文件。</td><td>Block special files是在/dev中找到的特殊内核文件，主要用于硬盘、光盘、软盘之类的ATA设备，if[-b/dev/fd0]；然后添加if=floppy.img of=/dev/fd0 # <em>将图像写入软盘</em> fi</td></tr><tr><td>[ -c characterspecialfile ]</td><td>文件“characterspecialfile”存在，并且是特殊字符。</td><td>字符特殊文件是/dev中的特殊内核文件，用于各种目的(音频硬件、tty，还有/dev/null)。if[-c/dev/DSP]；然后cat raw.wav &gt; /dev/dsp # <em>这实际上适用于某些原始wav文件</em> fi</td></tr><tr><td>[ -d目录]</td><td>文件“目录”存在，并且是一个目录。</td><td>在UNIX风格中，目录是一种特殊的文件。kde]；thenecho“你好像是kde用户。”船方不负担装货费用</td></tr><tr><td>[ -e现有文件]</td><td>文件“existingfile”存在。</td><td>(与-a相同，参见该条目中的示例)</td></tr><tr><td>[ -f正则化]</td><td>文件“regularfile”存在，并且是一个常规文件。</td><td>常规文件既不是块或字符特殊文件，也不是目录。bashrc]；然后source ~/。巴什尔菲</td></tr><tr><td>[ -g sgidfile ]</td><td>文件“sgidfile”存在，并且是set-group-ID。</td><td>当在一个目录上设置了SGID位时，在该目录中创建的所有文件都将继承该目录的组。选择<a href="https://acloudguru.com/blog/engineering/the-awk-command-bash-basics">创建的文件正在继承组“$(ls -ld。工作目录中的| awk“{ print $ 4 }”，"fi </a></td></tr><tr><td>[-g fileownebyeffective group]</td><td>文件“fileownedbyeffectivegroup”存在，并由有效的组ID拥有。</td><td>有效组id是执行用户的主要组id。-G文件]；然后# <em>感叹号反转它后面的条件的结果</em> chgrp $(id -g) file # <em>如果它不是有效的组，则更改该组</em> fi</td></tr><tr><td>[ -h符号]</td><td>文件“symboliclink”存在，并且是一个符号链接。</td><td>if[-h $ pathtofile]；然后pathtofile = $(read link-e $pathtofile)#<em>确保$ pathtofile包含实际文件，而不是指向它的符号链接</em> fi</td></tr><tr><td>[ -k stickyfile ]</td><td>文件“stickyfile”存在，并设置了其sticky位。</td><td>粘性位已经有了相当长的历史，但是现在被用来防止任何人删除全球可写目录的内容。-k/tmp]；然后# <em>一个感叹号反转它后面条件的结果</em>回显“警告！任何人都可以在/tmp中删除和/或重命名您的文件！”船方不负担装货费用</td></tr><tr><td>[ -L符号链接]</td><td>文件“symboliclink”存在，并且是一个符号链接。</td><td>(与-h相同，有关示例，请参见该条目)</td></tr><tr><td>[-N modifiedsinclastread]</td><td>文件“modifiedsincelastread”存在，并且在上次读取后被修改。</td><td>if[-N/etc/crontab]；然后killall -HUP crond # <em> SIGHUP让crond重新读取所有crontabs </em> fi</td></tr><tr><td>[-fileownebyeffective user]</td><td>文件“fileownedbyeffectiveuser”存在，由执行脚本的用户所有。</td><td>if [ -O文件]；chmod 600 file # <em>将文件设为私有，如果您不拥有它</em> fi，这是一个坏主意</td></tr><tr><td>[ -p namedpipe ]</td><td>文件“namedpipe”存在，并且是一个命名管道。</td><td>命名管道是/dev/fd/中的一个文件，只能读取一次。参见<a title="See" href="https://www.linuxtutorialblog.com/post/tutorial-the-best-tips-tricks-for-bash#using-several-ways-of-substitution" target="_blank" rel="nofollow noopener noreferrer">我的bash教程</a>中使用它的案例. if[-p $ file]；然后CP＄file tmp . tmp #<em>确保我们能够任意多次读取该文件</em> file="tmp.tmp" # <em/></td></tr><tr><td>[ -r readablefile ]</td><td>文件“readablefile”存在，并且对于脚本是可读的。</td><td>if [-r文件]；然后content=$(cat file) # <em>将$content设置为文件</em> fi的内容</td></tr><tr><td>[ -s非空文件]</td><td>文件“nonemptyfile”存在，其大小超过0字节。</td><td>if [ -s日志文件]；然后zip日志文件# <em>备份旧的日志文件</em>在创建新的日志文件之前，触摸日志文件# <em>。</em> fi</td></tr><tr><td>[ -S套接字]</td><td>文件“socket”存在，并且是一个套接字。</td><td>socket文件用于进程间通信，具有类似于网络连接的接口。然后mysql–socket =/var/lib/MySQL/MySQL . sock #<em>见<a title="MySQL" href="https://www.tech-recipes.com/mysql_tips762.html" target="_blank" rel="nofollow noopener noreferrer">本MySQL提示</a> </em> fi</td></tr><tr><td>[ -t openterminal ]</td><td>文件描述符“openterminal”存在，并且引用了一个打开的终端。</td><td>在Linux/UNIX上，几乎所有的事情都是使用文件来完成的，终端也不例外。那里有个黑人。来自终端$(tty)的消息。”&gt;/dev/pts/3 # <em>任何使用该终端的人都会看到这条消息！</em> fi</td></tr><tr><td>[ -u suidfile ]</td><td>文件“suidfile”存在，并且设置为-user-ID。</td><td>在文件上设置suid位会导致使用文件所有者的凭据而不是执行用户的凭据来执行该文件。thenecho "正在以用户$(ls-l executable | awk“{ print $ 3 }”)身份运行程序可执行文件。船方不负担装货费用</td></tr><tr><td>[ -w可写文件]</td><td>文件“writeablefile”存在，并且可写入脚本。</td><td>if[-w/dev/hda]；然后grub-install /dev/hdafi</td></tr><tr><td>[ -x executablefile ]</td><td>文件“executablefile”存在，并且可由脚本执行。</td><td>请注意，对目录的执行权限意味着它是可搜索的(您可以看到它包含哪些文件)。if[-x/root]；选择“您可以查看/根目录的内容。”船方不负担装货费用</td></tr><tr><td>[ newerfile -nt olderfile ]</td><td>文件“newerfile”比“olderfile”更新，或者如果“newerfile”存在而“olderfile”不存在。</td><td>if[story . txt 1-nt story . txt]；thenecho "story.txt1比story.txt新；我建议继续前者。”船方不负担装货费用</td></tr><tr><td>[ olderfile -ot newerfile ]</td><td>文件“olderfile”比“newerfile”早更改，或者如果“newerfile”存在而“olderfile”不存在。</td><td>if[/mnt/remote/remote file-ot local file]；然后CP-f local file/mnt/remote/remote file #<em>确保远程位置也有文件的最新版本</em> fi</td></tr><tr><td>[相同的ef文件]</td><td>文件“相同”和文件“文件”指的是相同的设备/信息节点号。</td><td>if[/dev/cdrom-ef/dev/DVD]；选择“您的主cd驱动器似乎也能读取dvd。”船方不负担装货费用</td></tr><tr><td><h3> <a title="string-based-conditions" name="string-based-conditions"/> 2。基于字符串的条件:</h3></td></tr><tr><th>情况</th><th>如果为真</th><th>示例/解释</th></tr><tr><td>[ STRING1 == STRING2 ]</td><td>STRING1等于STRING2。</td><td>if[" $ 1 " = = " moo "]；thenecho $cow # <em>试过执行“apt-get moo”吗？</em> fiNote:也可以用单个“=”代替双个。</td></tr><tr><td>【STRING1！= STRING2 ]</td><td>STRING1不等于STRING2。</td><td>if [ "$userinput "！= " $ password "]；thenecho "拒绝访问！密码错误！”退出1 # <em>在这里停止脚本执行</em> fi</td></tr><tr><td>[字符串1 &gt;字符串2 ]</td><td>在当前区域设置中，STRING1在STRING2之后排序(按词法)。</td><td>尖括号前有反斜杠，因为需要对括号进行转义才能正确解释。作为一个例子我们有一个基本的<a title="What is a bubble sort? See wikipedia!" href="https://en.wikipedia.org/wiki/Sorting_algorithm#Bubble_sort">冒泡排序</a> : <em>(如果你不理解这个不要觉得惭愧，这是一个更复杂的例子)</em> array=( linux教程博客)swaps = 1 while((swaps&gt;0))；doswaps = 0 for((I = 0；I&lt;(($ { # array[@]}–1))；i++))；doif[" $ { array[$ I]} "&gt;" $ { array[$((I+1))]} "]；然后# <em>这里是排序条件</em>tempstring = $ { array[$ I]} array[$ I]= $ { array[$((I+1))]} array[$((I+1))]= $ tempstring((swaps = swaps+1))fidonedonecho $ { array[@]} #<em>返回《博客linux教程》</em></td></tr><tr><td>[字符串1 </td><td>在当前区域设置中，STRING1在STRING2之前排序(按词法)。</td></tr><tr><td>[ -n非EMPTYSTRING ]</td><td>NONEMPTYSTRING的长度大于零。</td><td>这个条件只接受有效的字符串，所以一定要用引号括起你给它的任何内容。then user input = parse($ user input)#<em>只有当用户实际输入时才进行解析。</em>请注意，您也可以省略“-n”，因为只有一个字符串的括号的行为是相同的。</td></tr><tr><td>[ -z EMPTYSTRING ]</td><td>EMPTYSTRING是一个空字符串。</td><td>这个条件也接受非字符串输入，比如未初始化的变量:if[-z $ uninitializedvar]；thenuinitializedvar = " initialized " #<em>-z对未初始化的变量返回true，所以我们在这里初始化它。</em> fi</td></tr><tr><td><em>仅双括号语法:</em>[[string 1 = ~ regexpartern]]</td><td>STRING1匹配REGEXPATTERN。</td><td>如果您熟悉正则表达式，可以使用这些条件来执行正则表达式匹配。_%+-]+@[A-Za-z0-9。-]+.[A-Za-z]{2，4 } b "]]；thenecho "$email包含有效的电子邮件地址。"船方不负担装货费用</td></tr><tr><td><h3> <a title="arithmetic-conditions" name="arithmetic-conditions"/> 3。算术(基于数字)条件:</h3></td></tr><tr><th>情况</th><th>如果为真</th><th>示例/解释</th></tr><tr><td>[1到2之间的1-eq]</td><td>NUM1与NUM2相等。</td><td>这些条件只接受整数。如果可能的话，字符串将被转换成整数。一些随机的例子:如果[ $？-eq 0]；然后# <em> $？返回前一个命令</em>的退出状态，显示“前一个命令成功运行”fiif[$(PS-p $ PID-o ni =)-ne $(nice)]；thenecho "Process $pid正在使用非默认的nice值" fiif [ $num -lt 0 ]运行；不允许负数；退出…”退出1fi</td></tr><tr><td>[一对二]</td><td>NUM1是not<strong>e</strong>哪个是NUM2。</td></tr><tr><td>[1-gt乘以2 ]</td><td>NUM1是<strong> G </strong> reater <strong> T </strong> han NUM2。</td></tr><tr><td>[一格二]</td><td>NUM1大于或等于NUM2的T2。</td></tr><tr><td>[编号1 -lt编号2 ]</td><td>NUM1是<strong> L </strong> ess <strong> T </strong>韩NUM2。</td></tr><tr><td>[一二三]</td><td>NUM1比NUM2小或等于num 2。</td></tr><tr><td><h3> <a title="miscellaneous-conditions" name="miscellaneous-conditions"/> 4。其他条件:</h3></td></tr><tr><th>情况</th><th>如果为真</th><th>示例/解释</th></tr><tr><td>[ -o shelloption ]</td><td>外壳选项“shell option”已启用。</td><td>Shell选项修改bash的行为，除了一些指示shell状态的不可修改的选项。-o checkwinsize ] # <em>感叹号反转其后条件的结果</em> echo "Shell选项checkwinsize被禁用；启用它，这样您就可以毫无问题地调整终端窗口的大小。”shopt -s checkwinsize # <em>此shell选项可修改</em>fiif[-o log in _ shell]；thenecho“这是一个登录外壳。”# <em>此外壳选项不可修改</em> fi</td></tr></tbody></table></figure><p>使用双括号语法，您可以使用以下条件:</p><figure class="wp-block-table"><table><tbody><tr><td><h3> <a title="double-parenthesis-syntax-conditions" name="double-parenthesis-syntax-conditions"/> 5。双括号语法条件:</h3></td></tr><tr><th>情况</th><th>如果为真</th><th>示例/解释</th></tr><tr><td>(第1季第2集)</td><td>NUM1等于NUM2。</td><td>这些条件只接受整数。如果可能的话，字符串将被转换成整数。一些随机的例子:if (( $？== 0 ));然后# <em> $？返回前一个命令</em>的退出状态，显示“前一个命令成功运行”fiif (( $(ps -p $pid -o ni=)！= $(nice)))；thene CHO“Process $ PID正在以非默认的好值运行”fiif(($ num&lt;0))；不允许负数；退出…”退出1fi</td></tr><tr><td>(1号！=第2个)</td><td>NUM1不等于NUM2。</td></tr><tr><td>(编号1 &gt;编号2)</td><td>NUM1大于NUM2。</td></tr><tr><td>((数字1 &gt;=数字2))</td><td>NUM1大于等于NUM2。</td></tr><tr><td>(编号1 </td><td>NUM1小于NUM2。</td></tr><tr><td>(数字1 &lt;=数字2)</td><td>NUM1小于等于NUM2。</td></tr></tbody></table></figure><p>在这些枯燥的信息之后，这里有一些解释给那些想知道更多的人…</p><h2 id="h-diving-a-little-deeper"><a title="diving-a-little-deeper" name="diving-a-little-deeper"/>潜得更深一点</h2><p>我说过，如果本质上检查命令的退出状态，我会讲述更多关于<em>的事实。所以我会的。</em></p><p>bash关于条件的基本规则是<em> 0等于真，&gt; 0等于假</em>。</p><p>这与许多编程语言截然相反，0等于假，1(或更多)等于真。这背后的原因是bash之类的shells大量处理程序。按照UNIX惯例，程序使用退出状态来指示执行是否顺利或发生了错误。因为成功的执行不需要任何解释，它只需要一个退出状态。然而，如果有问题，知道哪里出了问题是很有用的。因此，0表示成功执行，1-255表示发生了哪种错误。</p><p>数字1-255的含义因返回它们的程序而异。</p><p>总之，<em>如果</em>在<em>之后执行程序块，那么</em>当命令返回0时。是的，条件就是命令。短语[ $foo -ge 3 ]返回一个退出状态，另外两个语法也是如此！因此，有一个简单的技巧可以用来快速测试一个条件:</p><pre class="wp-block-code"><code>[ $foo -ge 3 ] &amp;&amp; echo true</code></pre><p>在本例中，“echo true”仅在“$foo -ge 3”返回0 (true)时执行。你可能会问，这是为什么。这是因为bash只在需要的时候评估一个条件。当使用<em>和</em>组合表达式时，两个条件都需要为真才能使组合表达式返回真。如果第一个条件返回false，那么第二个条件返回什么并不重要；结果将是假的。</p><p>因此，bash不会计算第二个条件，这也是示例中不执行“echo true”的原因。这同样适用于<em>或</em>操作符(" || ")，其中如果第一个条件为真，则不计算第二个条件。嗯，潜水到此为止。</p><p>如果你想知道更多，我想给你介绍一下<a title="Go" href="https://www.tldp.org/LDP/abs/html/tests.html" target="_blank" rel="nofollow noopener noreferrer">高级Bash脚本指南</a>和<a title="Read" href="https://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs" target="_blank" rel="nofollow noopener noreferrer"> Bash参考手册</a>。你也可以看看我们的课程<a href="https://acloudguru.com/course/the-system-administrators-guide-to-bash-scripting-2" target="_blank" rel="noreferrer noopener">Bash脚本系统管理员指南</a>。</p><h2 id="h-conclusion"><a title="conclusion" name="conclusion"/>结论</h2><p>在本教程中，您已经能够开始理解bash脚本中条件的许多可能性。您已经了解了编写和使用条件的基本规则，了解了三种语法及其属性，并且可能利用这个机会进行了更深入的研究。</p><p>我希望你像我喜欢写作一样喜欢阅读。您可以随时返回此处，在<a href="#h-table-of-conditions">表</a>中查找条件(将该链接标记为书签以直接查看该表)，或者刷新您的知识。感谢阅读和快乐脚本！</p><p><em>想提升你的技术水平吗？<a href="https://www.youtube.com/c/AcloudGuru/?sub_confirmation=1" target="_blank" rel="noreferrer noopener">在YouTube上订阅一位云专家</a>，在<a href="https://www.facebook.com/acloudguru" target="_blank" rel="noreferrer noopener">脸书</a>上喜欢我们，在<a href="https://twitter.com/acloudguru" target="_blank" rel="noreferrer noopener"> Twitter </a>上关注我们，或者在<a href="http://discord.gg/acloudguru" target="_blank" rel="noreferrer noopener"> Discord </a>上加入对话！</em></p></div></div>    
</body>
</html>