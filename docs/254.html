<html>
<head>
<title>Build your own multi-user photo album app with React, GraphQL, and AWS Amplify — Part 2 of 3 | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React、GraphQL和AWS Amplify构建您自己的多用户相册应用程序—第2部分，共3部分|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part2#0001-01-01">https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part2#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p class="has-text-align-center" id="h-add-url-routing-photo-uploads-and-an-album-details-view">添加URL路由、照片上传和相册详细信息视图</p><p><a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part1" target="_blank" rel="noreferrer noopener"> <strong> <em>第一部分</em> </strong> </a> <strong> <em> |第二部分| </em> </strong> <a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part3" target="_blank" rel="noreferrer noopener"> <strong> <em>第三部分</em> </strong> </a> <em> <br/>这是一个由三部分组成的系列文章的第二篇，向您展示如何在AWS上构建一个可扩展的、高度可用的无服务器web应用程序，允许用户将照片上传到相册并与他人私下共享这些相册。</em></p><hr class="wp-block-separator is-style-dots"/><p><strong>注意:</strong>自从这个系列的最初出版以来，我已经将这些内容改编成了一个可在线访问的自定进度的研讨会，网址:【https://amplify-workshop.go-aws.com/】<br/><a href="https://amplify-workshop.go-aws.com/" target="_blank" rel="noreferrer noopener"/></p><hr class="wp-block-separator is-style-dots"/><p id="4c18">在<a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part1" target="_blank" rel="noreferrer noopener">第一部分</a>中，我们启动了我们的应用程序，添加了身份验证，并集成了一个GraphQL API，用于通过web前端创建相册记录，让我们列出相册名称并创建新的相册名称。</p><p id="8a79">在第二部分中，我们将进行以下改进:</p><ul><li>添加URL路由和视图，以便在相册列表和查看相册详细信息之间切换</li><li>使用S3将照片上传到相册，在云中自动生成缩略图，并将照片元数据存储在另一个DynamoDB表中，这样我们就可以将照片链接到相册</li><li>使用GraphQL模式中相册类型内的嵌套照片字段获取所选相册的所有照片</li></ul><h3 id="0f09">先决条件</h3><p id="d33a">在我们继续下面的步骤之前，我们还有一个要求。</p><p id="d33a"><strong>安装SAM CLI </strong> —在本文中，我们将使用AWS的一个工具来帮助打包和部署AWS Lambda函数，该工具名为<a href="https://github.com/awslabs/serverless-application-model" target="_blank" rel="noreferrer noopener"> AWS无服务器应用程序模型(SAM) </a>和<a href="https://github.com/awslabs/aws-sam-cli" target="_blank" rel="noreferrer noopener"> SAM CLI </a>。请遵循SAM CLI 的<a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" target="_blank" rel="noreferrer noopener">安装说明，这也需要您安装Docker(SAM安装说明中提供了相关链接)。</a></p><h3 id="205e">添加路由和相册详细信息视图</h3><p id="289b">首先，因为我们希望有两种模式——一个相册列表视图和一个相册细节视图——让我们使用<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noreferrer noopener"> react-router-dom </a>和一些新组件为React应用程序添加一些简单的路由，以帮助加载相册的细节和呈现相册。<br/> <br/>跑<code>npm install --save react-router-dom</code></p><p id="63a4">然后，在<code>App.js</code>的顶部添加一些导入，创建一些新的组件来加载和呈现一个相册，并修改我们的应用程序组件来根据我们所处的路线呈现不同的组件。对<code>src/App.js</code>进行以下更改。</p><pre class="wp-block-code"><code>// src/App.js
// 1. NEW: Import the routing components
import {BrowserRouter as Router, Route, NavLink} from 'react-router-dom';

// 2. NEW: Add a new query we can use to render an album's details
const GetAlbum = `query GetAlbum($id: ID!) {
  getAlbum(id: $id) {
    id
    name
  }
}
`;

// 3. NEW: Create an AlbumDetailsLoader component
//    to load the details for an album
class AlbumDetailsLoader extends React.Component {
  render() {
    return (
      &lt;Connect query={graphqlOperation(GetAlbum, { id: this.props.id })}&gt;
        {({ data, loading, errors }) =&gt; {
          if (loading) { return &lt;div&gt;Loading...&lt;/div&gt;; }
          if (errors.length &gt; 0) { return &lt;div&gt;{JSON.stringify(errors)}&lt;/div&gt;; }
          if (!data.getAlbum) return;
          return &lt;AlbumDetails album={data.getAlbum} /&gt;;
        }}
      &lt;/Connect&gt;
    );
  }
}

// 4. NEW: Create an AlbumDetails component
class AlbumDetails extends Component {
  render() {
    return (
      &lt;Segment&gt;
        &lt;Header as='h3'&gt;{this.props.album.name}&lt;/Header&gt;
        &lt;p&gt;TODO: Allow photo uploads&lt;/p&gt;
        &lt;p&gt;TODO: Show photos for this album&lt;/p&gt;
      &lt;/Segment&gt;
    )
  }
}
// 5. EDIT: Replace the App component's render() method 
//    with updated code to control which components 
//    render depending on what route we're on
class App extends Component {
  // ...
  // Leave other parts of the App component alone
  // ...

  // Replace the render() method with this version: 
  render() {
    return (
      &lt;Router&gt;
        &lt;Grid padded&gt;
          &lt;Grid.Column&gt;
            &lt;Route path="/" exact component={NewAlbum}/&gt;
            &lt;Route path="/" exact component={AlbumsListLoader}/&gt;
            &lt;Route
              path="/albums/:albumId"
              render={ () =&gt; &lt;div&gt;&lt;NavLink to='/'&gt;Back to Albums list&lt;/NavLink&gt;&lt;/div&gt; }
            /&gt;
            &lt;Route
              path="/albums/:albumId"
              render={ props =&gt; &lt;AlbumDetailsLoader id={props.match.params.albumId}/&gt; }
            /&gt;
          &lt;/Grid.Column&gt;
        &lt;/Grid&gt;
      &lt;/Router&gt;
    );
  }
}</code></pre><p>我们的应用程序在这一点上看起来没有任何不同，但是如果我们修改AlbumsList组件，将相册名称呈现为遵循上面设置的路由路径的链接，我们应该能够点击并查看相册。当然，当我们查看一个相册的详细信息时，我们也需要一个链接来返回相册列表。让我们把这些都加进去。对<code>src/App.js</code>进行以下更改:</p><pre class="wp-block-code"><code>// src/App.js
// 1. EDIT: Replace the AlbumsList component's albumItems()
//    with updated code to output the names as nav links
class AlbumsList extends React.Component {
  // Replace the existing albumItems() with this new one:
  albumItems() {
    return this.props.albums.sort(makeComparator('name')).map(album =&gt;
      &lt;List.Item key={album.id}&gt;
        &lt;NavLink to={`/albums/${album.id}`}&gt;{album.name}&lt;/NavLink&gt;
      &lt;/List.Item&gt;
    );
  }
  
  // ... the rest of the AlbumsList component remains unchanged
}</code></pre><p id="7b52">此时，如果您查看该应用程序，您会看到我们可以单击某个专辑的名称，然后我们将更改视图并查看该专辑的详细信息(此外，我们在顶部有一个链接，可以返回到我们的专辑列表)。当然，现在我们所有的AlbumDetails组件所做的是呈现专辑的名称，加上一些我们稍后会用到的待办事项。在我们添加上传照片到相册的功能之前，我们不会获取任何其他相册信息，所以接下来让我们来处理这个问题。</p><h3 id="0a07">将照片上传添加到相册</h3><p id="99d7">我们需要一个地方来存储上传到我们相册的所有照片，亚马逊简单存储服务(S3)是一个很好的选择。首先，我们将使用Amplify CLI为我们的应用程序启用存储，这将在亚马逊S3上创建一个存储桶，并为其设置适当的权限，以便登录到我们应用程序的用户可以在不同的位置和权限对其进行读写。您可以点击了解更多关于存储模块<a href="https://aws-amplify.github.io/amplify-js/media/storage_guide" target="_blank" rel="noreferrer noopener">的信息。</a></p><p id="c5b2">运行<code>amplify add storage</code>，在提示符下选择“<strong>内容</strong>，可以选择为资源类别和桶名输入您自己的名称，并对其进行配置，以便只有经过身份验证的用户才能访问，并具有完全的读/写权限。然后运行<code>amplify push</code>。以下是一些带有响应的示例输出:</p><pre class="wp-block-code"><code>$ amplify add storage
? Please select from one of the below mentioned services: Content (Images, audio, video, etc.)
? Please provide a friendly name for your resource that will be used to label this category in the project: photoalbumsstorage
? Please provide bucket name: &lt;accept the default value&gt;
? Who should have access: Auth users only
? What kind of access do you want for Authenticated users: read/write
$ amplify push</code></pre><p>现在我们有了一个可以存储照片的S3存储桶，我们想创建一个UI，让我们可以将照片上传到这个存储桶中进行存储。然后，我们需要跟踪该照片被上传到相册的意图，以便我们最终可以加载属于特定相册的所有照片。<br/> <br/>让我们创建一个新的<code>S3ImageUpload</code>组件，它将包含一个HTML文件输入元素，当用户选择一张照片时，它将触发一个事件处理程序。我们的上传事件处理程序将需要上传文件到S3与一些元数据注释它的目的地专辑。幸运的是，<a href="https://aws-amplify.github.io/amplify-js/media/storage_guide" target="_blank" rel="noreferrer noopener"> Amplify JS存储模块</a>让上传文件到S3变得非常容易。此外，我们需要为我们的应用程序引入一个新的依赖项——一种生成UUIDs的方法——因为我们需要确保上传到S3的文件具有唯一的名称(如果我们使用用户设备上的文件名，它们可能会冲突)。<br/> <br/>运行<code>npm install --save uuid</code>然后更新我们的<code>src/App.js</code>文件，添加一些导入，创建一个<code>S3ImageUpload</code>组件，并将<code>S3ImageUpload</code>组件包含在<code>AlbumDetails</code>组件中。对<code>src/App.js</code>进行以下更改:</p><pre class="wp-block-code"><code>// src/App.js
// 1. NEW: Add imports from uuid and semantic-ui-react
import {v4 as uuid} from 'uuid';
import { Form, Grid, Header, Input, List, Segment } from 'semantic-ui-react';

// 2. EDIT: add an import of Storage from Amplify
import Amplify, { API, graphqlOperation, Storage } from 'aws-amplify';

// 3. NEW: Create an S3ImageUpload component
class S3ImageUpload extends React.Component {
  constructor(props) {
    super(props);
    this.state = { uploading: false }
  }
  onChange = async (e) =&gt; {
    const file = e.target.files[0];
    const fileName = uuid();
    this.setState({uploading: true});
    const result = await Storage.put(
      fileName, 
      file, 
      {
        customPrefix: { public: 'uploads/' },
        metadata: { albumid: this.props.albumId }
      }
    );
    console.log('Uploaded file: ', result);
    this.setState({uploading: false});
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Form.Button
          onClick={() =&gt; document.getElementById('add-image-file-input').click()}
          disabled={this.state.uploading}
          icon='file image outline'
          content={ this.state.uploading ? 'Uploading...' : 'Add Image' }
        /&gt;
        &lt;input
          id='add-image-file-input'
          type="file"
          accept='image/*'
          onChange={this.onChange}
          style={{ display: 'none' }}
        /&gt;
      &lt;/div&gt;
    );
  }
}

// 4. EDIT: Add the S3ImageUpload component 
//    to the AlbumDetails component
class AlbumDetails extends Component {
  render() {
    return (
      &lt;Segment&gt;
        &lt;Header as='h3'&gt;{this.props.album.name}&lt;/Header&gt;
        &lt;S3ImageUpload albumId={this.props.album.id}/&gt;        
        &lt;p&gt;TODO: Show photos for this album&lt;/p&gt;
      &lt;/Segment&gt;
    )
  }
}</code></pre><p>在这一点上没有太多要看的，但是你应该能够点击按钮，选择一个文件，并看到它改变为<em>‘Uploading…’</em>，然后再次切换回上传按钮。您还可以在AWS web控制台中手动浏览S3桶，查看文件是否正在上传。找到bucket名称最简单的方法是查看<code>src/aws-exports.js</code>并找到为<code>aws_user_files_s3_bucket</code>配置的值。在S3网络控制台中找到你的桶，然后在<code>public/uploads</code>下的桶中查找。<br/> <br/>在我们的新<code>S3ImageUpload</code>组件中，有一些东西值得一提。它使用AWS Amplify的<code>Storage.put</code>方法将文件上传到我们为应用程序配置的S3桶中。在这个API调用中，我们传递了一些额外的选项。<br/> <br/>我们传入<code>customPrefix: { public: 'uploads/' }</code>是因为我们想自动为每张图片制作缩略图。我们将通过在S3存储桶上添加一个触发器来完成这个任务，每当任何文件被添加到存储桶的<code>uploads/</code>路径时，这个触发器将为我们触发一个缩略图创建功能。新的缩略图也将被添加到桶中，为了避免递归触发器循环，其中每个缩略图的创建都会导致函数再次触发，我们将我们的触发器限定为只对添加了关键字前缀<code>uploads/</code>的文件执行。Amplify知道使用我们的前缀，因为我们指定它用于应该公开访问的文件，这是<code>Storage.put</code>的默认权限级别。</p><p>默认情况下，应用程序中的任何用户都可以访问(在API级别)所有文件，这有问题吗？不。这是可以接受的，因为我们对照片键使用了不可访问的UUID，如果用户知道某个相册的UUID，他们将只能检索该相册的照片列表。如果你去阅读所有的Amplify存储模块的API(或者如果你熟悉底层的S3 API)，你可能会问“但是等等，用户可以只列出公共路径中的所有对象并看到所有的照片！”目前，你是对的，但我们稍后会处理这个问题，在我们的应用程序工作并采取额外的预防措施来进一步锁定它(通过将相册列表限制到某些用户名，并防止用户在桶中列出项目)。<br/> <br/>我们传入<code>metadata: { albumid: this.props.albumId }</code>，因为我们要让我们的缩略图<a href="https://acloudguru.com/hands-on-labs/setting-up-lambda-functions-with-s3-event-triggers">S3λ触发器</a>函数在完成缩略图制作后，负责将关于这张照片的信息添加到我们的数据存储中，并且该函数需要知道照片上传到了哪个相册。例如，我们可以将相册ID作为前缀或后缀放在photo key中，但我认为元数据方法更好。毕竟这个<em>是关于照片的</em>元数据吧？</p><h3 id="ba31">生成缩略图</h3><p id="c660">基于AWS构建的一个好处是服务之间的集成。在我们的例子中，我们希望有一些服务器端代码为我们上传的每张图片生成缩略图。在AWS上，我们可以通过创建一个AWS Lambda函数并设置我们的S3桶来在新对象进入桶时触发该函数，以无服务器的方式实现这一点。AWS Lambda允许你用多种编程语言创作函数，但由于我们目前为止在这个应用程序中只使用JavaScript，所以让我们留在JS领域，创建一个将在Node.js 8.10上运行的Lambda函数。有很多选项可以帮助您在AWS Lambda上创作和部署函数。对于本教程，我们将使用<a href="https://github.com/awslabs/serverless-application-model" target="_blank" rel="noreferrer noopener"> AWS无服务器应用程序模型(SAM) </a>和<a href="https://github.com/awslabs/aws-sam-cli" target="_blank" rel="noreferrer noopener"> SAM CLI </a>。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/09a41e134ecaec3c0ba74a3ab62067a0.png" alt="" class="wp-image-42763" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_4trNpVeaxd3UKGMdDP-GVQ.png"/><figcaption>SAM: The AWS Serverless Application Model</figcaption></figure></div><p id="ee44">首先，遵循SAM CLI 的<a href="https://github.com/awslabs/aws-sam-cli/blob/develop/docs/installation.rst" target="_blank" rel="noreferrer noopener">安装说明。<br/> <br/>然后，在我们的<code>photo-albums</code>项目目录中，使用SAM CLI引导一个新的Node.js 8.10函数。</a></p><p id="e9f2">运行<code>sam init --runtime nodejs8.10 --name photo_processor</code> <br/> <br/>这将在<code>photo_processor/hello_world</code>中创建一个示例函数。让我们把<code>photo_processor/hello_world</code>改名为更合适的名字:<code>photo_processor/src</code>。此外，虽然我是单元测试的粉丝，但我们不打算在本教程中编写任何单元测试，所以删除<code>photo_processor/src/tests</code>目录，因为一旦我们编写了照片处理代码，那里的占位符测试就无关紧要了。现在是时候开始写一些代码来响应来自S3桶的事件和调整我们的上传了。在撰写本文时，在Node.js中执行照片大小调整的一个流行选择是<a href="http://sharp.dimens.io/en/stable/" target="_blank" rel="noreferrer noopener"> Sharp </a>，因此下面是我们的AWS Lambda函数，我们应该将它放在<code>photo_processor/src/app.js</code>中。</p><p id="e9f2">当我们在这里使用S3 API时，我们还将包含处理从上传文件中获取元数据所需的代码，因为在本文后面将照片信息存储到DynamoDB时，我们将需要这些信息。</p><p id="07cd">将此内容粘贴到<code>photo_processor/src/app.js</code>:</p><pre class="wp-block-code"><code>// photo_processor/src/app.js
const AWS = require('aws-sdk');
const S3 = new AWS.S3({ signatureVersion: 'v4' });
// Note: Sharp requires native extensions. To get sharp to install from NPM in a
// way that's compatible with the Amazon Linux environment that AWS runs Node.js
// on, we can use this command: docker run -v "$PWD":/var/task lambci/lambda:build-nodejs8.10 npm install
const Sharp = require('sharp');
// We'll expect these environment variables to be defined when the Lambda function is deployed
const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10);
const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10);
function thumbnailKey(filename) {
    return `public/resized/${filename}`;
}
function fullsizeKey(filename) {
    return `public/${filename}`;
}
function makeThumbnail(photo) {
    return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer();
}
async function resize(bucketName, key) {
    const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body;
    const originalPhotoName = key.replace('uploads/', '');
    const originalPhotoDimensions = await Sharp(originalPhoto).metadata();
    const thumbnail = await makeThumbnail(originalPhoto);
    await Promise.all([
        S3.putObject({
            Body: thumbnail,
            Bucket: bucketName,
            Key: thumbnailKey(originalPhotoName),
        }).promise(),
        S3.copyObject({
            Bucket: bucketName,
            CopySource: bucketName + '/' + key,
            Key: fullsizeKey(originalPhotoName),
        }).promise(),
    ]);
    await S3.deleteObject({
        Bucket: bucketName,
        Key: key
    }).promise();
    return {
        photoId: originalPhotoName,
        
        thumbnail: {
            key: thumbnailKey(originalPhotoName),
            width: THUMBNAIL_WIDTH,
            height: THUMBNAIL_HEIGHT
        },
        fullsize: {
            key: fullsizeKey(originalPhotoName),
            width: originalPhotoDimensions.width,
            height: originalPhotoDimensions.height
        }
    };
};
async function processRecord(record) {
    const bucketName = record.s3.bucket.name;
    const key = record.s3.object.key;
    if (key.indexOf('uploads') != 0) return;
    return await resize(bucketName, key);
}
exports.lambda_handler = async (event, context, callback) =&gt; {
    try {
        event.Records.forEach(processRecord);
        callback(null, { status: 'Photo Processed' });
    }
    catch (err) {
        console.error(err);
        callback(err);
    }
};</code></pre><p>接下来，用下面的文件替换自动生成的package.json文件，这样我们就可以跟踪我们对Sharp的依赖。将以下内容粘贴到<code>photo_processor/src/package.json</code>:</p><pre class="wp-block-code"><code>{
  "name": "photo_processor",
  "version": "1.0.0",
  "description": "Our Photo Album uploads processor",
  "main": "src/app.js",
  "dependencies": {
    "sharp": "^0.20.2"
  }
}</code></pre><p id="3cd9">最后，安装我们函数的依赖项。我们使用的是Sharp，它需要本地扩展作为其安装的一部分，因此我们需要让NPM在亚马逊Linux环境中安装Sharp，因为AWS Lambda将在该操作系统上运行我们的功能。幸运的是，有一个docker图像可以使这变得容易。<br/> <br/>从photo_processor/src目录中，运行<code>docker run -v "$PWD":/var/task lambci/lambda:build-nodejs8.10 npm install</code> <br/> <br/>，它会处理我们需要的一切，以便将我们的功能打包并部署到云中的AWS Lambda。</p><h3 id="6bfe">打包和部署Lambda函数</h3><p id="1c75">SAM CLI有助于引导Lambda函数(我们在上面已经做过了)，它还可以负责打包和部署Lambda函数。当我们引导我们的函数时，SAM CLI还生成了一个SAM模板文件(YAML格式)，它将被预处理成AWS CloudFormation模板文件。生成的template.yml定义了一个Lambda函数，该函数在响应HTTP请求时被触发。</p><h4 id="53d7">创建SAM模板文件</h4><p id="47c2">在我们的例子中，我们想要定义一个Lambda函数，它有权限在我们的存储桶上工作并向Amazon CloudWatch写入日志。我们不需要设置HTTP端点触发器，但是我们希望包含调整大小函数所期望的缩略图宽度和高度环境变量。此外，由于我们的存储桶是使用不同的云形成模板(通过Amplify CLI)创建的，我们将配置该模板，以期望我们将存储桶的Amazon资源名称作为参数传入，以便我们可以设置适当的权限。下面的<br/> <br/>是一个负责这一切的SAM <code>template.yml</code>文件。用以下内容替换<code>photo_processor/template.yml</code>的内容:</p><pre class="wp-block-code"><code># photo_processor/template.yml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: &gt;
    photo_processor
    Sample SAM Template for photo_processor
Parameters:
    S3UserfilesBucketArn:
        Type: String
    
Globals:
    Function:
        Timeout: 10
Resources:
    PhotoProcessorFunctionIamRole: 
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                    - 
                        Effect: Allow
                        Principal:
                            Service: [lambda.amazonaws.com]
                        Action: ["sts:AssumeRole"]
            ManagedPolicyArns: ["arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"]
            Path: "/"
            Policies: 
                - 
                    PolicyName: "AllPrivsForPhotoAlbumUserfilesBucket"
                    PolicyDocument: 
                        Version: "2012-10-17"
                        Statement: 
                            -
                                Effect: "Allow"
                                Action: "s3:*"
                                Resource: !Join ["/", [!Ref S3UserfilesBucketArn, "*"]]
    PhotoProcessorFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: src/
            Handler: app.lambda_handler
            Role: !GetAtt PhotoProcessorFunctionIamRole.Arn
            Runtime: nodejs8.10
            Environment:
                Variables:
                    THUMBNAIL_WIDTH: 80
                    THUMBNAIL_HEIGHT: 80
    BucketPermission:
        Type: AWS::Lambda::Permission
        Properties:
            Action: 'lambda:InvokeFunction'
            FunctionName: !Ref PhotoProcessorFunction
            Principal: s3.amazonaws.com
            SourceAccount: !Ref "AWS::AccountId"
            SourceArn: !Ref S3UserfilesBucketArn
Outputs:
    PhotoProcessorFunction:
      Description: "Photo Processor Lambda Function ARN"
      Value: !GetAtt PhotoProcessorFunction.Arn
    PhotoProcessorFunctionIamRole:
      Description: "IAM Role created for Photo Processor function"
      Value: !GetAtt PhotoProcessorFunctionIamRole.Arn</code></pre><h4 id="2bea">打包SAM模板文件</h4><p id="734d">准备好SAM模板后，您需要让SAM打包您的Lambda函数，使其压缩函数及其依赖项，生成最终的CloudFormation模板，并将CloudFormation模板上传到S3存储桶(所有CloudFormation模板必须存在于S3存储桶中才能执行)。<br/> <br/>作为一次性操作，创建一个S3存储桶来托管这个(以及任何未来的云信息)模板，注意创建具有唯一名称的存储桶，并指定React应用程序的<code>src/aws-exports.js</code>文件中引用的相同区域。运行以下命令(使用适当的替换):</p><pre class="wp-block-code"><code>export MY_UNIQUE_CLOUDFORMATION_TEMPLATES_BUCKET_NAME=PickAUniqueNameHere
aws s3 mb s3://$MY_UNIQUE_CLOUDFORMATION_TEMPLATES_BUCKET_NAME --region us-east-1</code></pre><h4 id="bf38">部署SAM模板文件</h4><p id="1aa1">现在，我们将使用SAM CLI将我们的Lambda函数打包并部署到云中。从<code>photo_processor</code>目录中，运行:</p><pre class="wp-block-code"><code>sam package \
--template-file template.yaml \
--output-template-file packaged.yml \
--s3-bucket $MY_UNIQUE_CLOUDFORMATION_TEMPLATES_BUCKET_NAME</code></pre><p id="a40d">最后，是时候部署Lambda函数了。前面的命令在<code>template.yml</code>文件旁边创建了一个<code>packaged.yml</code>函数，并上传了一个lambda函数及其依赖项的zip文件。我们将在部署命令中引用它，但我们还需要传入一个参数来告诉CloudFormation我们的应用程序用于文件存储的S3存储桶的ARN。在React应用程序的<code>src/aws-exports.js</code>文件中查找<code>aws_user_files_s3_bucket</code>值，并在下面替换它。</p><p id="109e">在<code>photo_processor</code>目录中，运行(适当替换<code>S3UserfilesBucketArn</code>):</p><pre class="wp-block-code"><code>export MY_AWS_USERFILES_S3_BUCKET_ARN=arn:aws:s3:::my-aws-user-files-s3-bucket-name
sam deploy \
--template-file packaged.yml \
--stack-name PhotoAlbumsProcessorSAMStack \
--capabilities CAPABILITY_IAM \
--parameter-overrides \
--region us-east-1 \
S3UserfilesBucketArn=$MY_AWS_USERFILES_S3_BUCKET_ARN</code></pre><p id="b1b0">经过短暂的等待，我们的Lambda函数应该已经部署好了，可以连接到S3来调整照片的大小了！如果你愿意，你可以在<a href="https://github.com/awslabs/aws-sam-cli/blob/develop/docs/deploying_serverless_applications.rst" target="_blank" rel="noreferrer noopener">部署无服务器应用文档</a>中阅读更多关于用AWS SAM打包和部署Lambda函数的信息。</p><h3 id="7149">当照片上传到S3时调用我们的Lambda函数</h3><p id="73df">现在我们的照片大小调整Lambda函数已经部署好了，我们需要向它添加一个<em>事件源</em>,这样每当有新照片上传到我们的存储桶时，它就会被调用。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/5294f388bb70fdb06364d189dc2bf546.png" alt="" class="wp-image-42767" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_VoPMoIwNTaxqPNO07v8vjg.png"/><figcaption>Adding S3 uploads as a trigger for our photo_processor Lambda function</figcaption></figure></div><p id="3b31">以下是如何连接S3桶上传触发我们的Lambda:</p><ol><li>打开AWS web控制台，确保您位于我们的应用程序正在使用的同一区域，并加载Lambda控制台页面</li><li>找到我们的Lambda函数的名称，其中应该有“PhotoProcessorFunction”(如果您有很多函数，可以使用搜索框缩小函数列表)，然后单击该函数以查看和管理其配置</li><li>在页面顶部的设计器部分，从左侧的“添加触发器”列表中单击S3</li><li>在出现的“配置触发器”部分:<br/> a .选择您的存储桶的名称(您可以在<code>src/aws-exports.js</code>文件中查找)<br/> b .选择上传事件类型<br/> c .输入“上传/”作为前缀<br/> d .单击“添加”</li><li>点击右上角的橙色“保存”按钮</li></ol><p id="ec09">完成后，每当新照片出现在前缀为<code>uploads/</code>的S3桶中时，就应该调用照片大小调整Lambda函数。您可以通过使用相册详细信息web界面将新照片上传到相册来检查事情是否正常，然后使用S3 web控制台浏览存储桶的内容；在<code>public/</code>和<code>public/resized/</code>找一张同名的照片。</p><h3 id="e3b3">将照片元数据存储在DynamoDB中</h3><p id="b00e">在显示相册中的所有照片之前，我们的最后一步是向DynamoDB中的一个表添加一个新条目，其中包含关于照片的元数据。我们在第一部分中定义的GraphQL模式描述了一个连接到<code>Album</code>的<code>Photo</code>类型。如果我们将新项目放入我们的<a href="https://acloudguru.com/course/introduction-to-aws-appsync"> AppSync </a> Photo的datasource中描述的表中，当我们试图通过GraphQL查询获取相册的嵌套照片时，该信息将是可用的。为了简单起见，我们将添加现有的<code>photo_processor</code> Lambda函数，而不是创建另一个函数。我们需要为插入到Dynamo中的每张照片生成一个唯一的ID，所以让我们引入另一个包。从<code>photo_processor/src</code>目录，运行:<code>npm install --save uuid</code> <br/> <br/>由于DynamoDB文档客户端类的存在，从JavaScript和AWS JS SDK使用DynamoDB变得非常容易。对<code>photo_processor/app.js</code>进行如下更改:</p><pre class="wp-block-code"><code>// photo_processor/app.js
// 1. NEW: Import the DynamoDB DocumentClient and the uuid module
const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: '2012-08-10'});
const uuidv4 = require('uuid/v4');

// 2. NEW: Extract the name of the photos table 
//    from an environment variable (we'll set this value via
//    our SAM template below...)
const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split('/')[1];

// 3. NEW: Add a new function to handle putting 
//    our new Photo info into DynamoDB
function storePhotoInfo(item) {
  const params = {
    Item: item,
    TableName: DYNAMODB_PHOTOS_TABLE_NAME
  };
  return DynamoDBDocClient.put(params).promise();
}

// 4. NEW: Add a new function to get the metadata for a photo
async function getMetadata(bucketName, key) {
  const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise();
  return headResult.Metadata;
}

// 5. EDIT: Replace processRecord() with this definition, 
//    which passes the metadata and the sizes info 
//    to storePhotoInfo(). 
//
//    We'll also add a createdAt property to our photo items 
//    which will be helpful when we get around to 
//    paginating photos in date order.
async function processRecord(record) {
  const bucketName = record.s3.bucket.name;
  const key = record.s3.object.key;
    
  if (key.indexOf('uploads') != 0) return;
    
  const metadata = await getMetadata(bucketName, key);
  const sizes = await resize(bucketName, key);    
  const id = uuidv4();
  const item = {
    id: id,
    owner: metadata.owner,
    photoAlbumId: metadata.albumid,
    bucket: bucketName,
    thumbnail: sizes.thumbnail,
    fullsize: sizes.fullsize,
    createdAt: new Date().getTime()
  }
  await storePhotoInfo(item);
}</code></pre><p>更新SAM <code>template.yml</code>文件，添加我们在上面介绍的新环境变量，并添加一个新的策略，允许我们的Lambda函数写入照片表:</p><pre class="wp-block-code"><code># photo_processor/template.yml
# ...
Parameters:
    # ...
    
    # 1. NEW: Add another parameter
    DynamoDBPhotosTableArn:
        Type: String
# ...
Resources:
    # ....
    PhotoProcessorFunctionIamRole:
        Properties:
            # ...
            Policies:
                # ...
                
                # 2. NEW: Add another policy
                - 
                    PolicyName: "AllPrivsForDynamo"
                    PolicyDocument: 
                        Version: "2012-10-17"
                        Statement: 
                            -
                                Effect: "Allow"
                                Action: "dynamodb:*"
                                Resource: 
                                    - !Ref DynamoDBPhotosTableArn
    
# ...
    
    PhotoProcessorFunction:
        # ...
            Environment:
                Variables:
                    # ...
                    
                    # 3. NEW: add a new environment 
                    #    variable referencing our param
                    DYNAMODB_PHOTOS_TABLE_ARN: !Ref DynamoDBPhotosTableArn</code></pre><p id="eb49">完成这些更改后，我们的<code>photo_processor</code> Lambda现在应该为每张上传的照片创建一个缩略图，并在我们的photos DynamoDB表中创建一个新记录，该记录包含让我们的前端很好地呈现相册所需的数据。</p><p id="a460">现在是时候部署Lambda函数的更新版本了(重复我们之前运行的相同的sam包和sam deploy命令)。假设之前导出的变量仍然存在(您在同一个终端会话中)，我们只需要为DynamoDB照片表ARN定义一个新的环境变量。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/135d08da9048cbe18c3bba5292ebf42b.png" alt="" class="wp-image-42768" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_f6RfUjvnZtKKhSBjJ32rCg.png"/><figcaption>Viewing the data sources for our AppSync AP</figcaption></figure></div><p id="ea6a">要查找正确的照片表，ARN:</p><ol><li>转到AWS AppSync web控制台中的API</li><li>单击“数据源”</li><li>找到PhotoTable条目，单击表名的链接，转到DynamoDB web控制台</li><li>复制DynamoDB表格概述选项卡底部的ARN</li></ol><p id="761f">找到ARN后，将其替换到下面的export语句中，并在SAM命令使用的同一终端窗口中运行以下命令(因此我们已经设置的其他环境变量仍然是定义的)。注意:不要改变下面的<code>stack-name</code>参数；我们希望它与Amplify创建的堆栈有所不同。</p><p id="4bd1">从<code>photo_processor</code>目录中，运行:</p><pre class="wp-block-code"><code># Fill in the value below with the ARN for your DynamoDB Photos table
export MY_DYNAMODB_PHOTOS_TABLE_ARN=my-dynamo-db-photos-table-arn
sam package \
--template-file template.yaml \
--output-template-file packaged.yml \
--s3-bucket $MY_UNIQUE_CLOUDFORMATION_TEMPLATES_BUCKET_NAME
sam deploy \
--template-file packaged.yml \
--stack-name PhotoAlbumsProcessorSAMStack \
--capabilities CAPABILITY_IAM \
--region us-east-1 \
--parameter-overrides \
S3UserfilesBucketArn=$MY_AWS_USERFILES_S3_BUCKET_ARN \
DynamoDBPhotosTableArn=$MY_DYNAMODB_PHOTOS_TABLE_ARN</code></pre><p id="e41a">从现在开始，我们从应用程序上传的任何新照片都应该在photos DynamoDB表中有一行。尝试从前端进行另一次上传，在下一部分，我们将看看是否可以通过GraphQL获取照片信息。</p><h3 id="d135">为相册获取照片</h3><p id="79ea">我们的GraphQL模式已经表明一个<code>Album</code>中有一个<code>Photos</code>字段(类型为<code>[Photo]</code>)。我们已经注意到向保存照片信息的DynamoDB表写入行，通过每张照片上传期间提供的<code>albumid</code>元数据将每个条目链接到一个相册。Amplify CLI已经编写了一个解析器来正确查找给定相册的相关照片。所以我们应该能够向GraphQL请求属于某个特定相册的照片。让我们试一试。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/8b2e7c15ed337e1d5242e8d4182f5731.png" alt="" class="wp-image-42765" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_PG0Cbtc_Oesrq57OY4ITjQ.png"/><figcaption>Querying our AWS AppSync API in the web console</figcaption></figure></div><p>回到AWS AppSync web控制台，转到查询部分并运行以下查询:</p><pre class="wp-block-code"><code>query AllAlbums {
  listAlbums {
    items {
      id
      name
      photos {
        items {
          id
          bucket
          thumbnail {
            width
            height
            key
          }
        }
      }
    }
  }
}</code></pre><p id="305d">如果自从我们上次部署Lambda以来，你在相册中添加了任何照片，你应该会看到一些相册也包含了照片！剩下的就是在我们的UI中显示这些图像。</p><h3 id="25ef">渲染相册中的所有照片</h3><p id="5cda">为了渲染每张照片，我们可以利用AWS Amplify JS库提供的另一个React组件:<code>S3Image</code>(你可以在这里阅读关于这个组件<a href="https://aws-amplify.github.io/amplify-js/media/storage_guide" target="_blank" rel="noreferrer noopener">的更多信息)。让我们更新我们的<code>GetAlbum</code>查询来获取相册的照片，创建一个新的<code>PhotosList</code>组件，并在我们的<code>AlbumDetails</code>组件中使用它。对<code>src/App.js</code>进行如下修改:</a></p><pre class="wp-block-code"><code>// src/App.js
// 1. NEW: Add an import of S3Image 
//    and add Divider to imports from semantic-ui-react
import { S3Image } from 'aws-amplify-react';
import { Divider, Form, Grid, Header, Input, List, Segment } from 'semantic-ui-react';

// 2. EDIT: Update our GetAlbum query to include 
//    fetching thumbnail info for each photo
const GetAlbum = `query GetAlbum($id: ID!) {
  getAlbum(id: $id) {
    id
    name
    photos {
      items {
        thumbnail {
          width
          height
          key
        }
      }
      nextToken
    }
  }
}
`;

// 3. NEW: Create a new PhotosList component
class PhotosList extends React.Component {
  photoItems() {
    return this.props.photos.map(photo =&gt;
      &lt;S3Image 
        key={photo.thumbnail.key} 
        imgKey={photo.thumbnail.key.replace('public/', '')} 
        style={{display: 'inline-block', 'paddingRight': '5px'}}
      /&gt;
    );
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Divider hidden /&gt;
        {this.photoItems()}
      &lt;/div&gt;
    );
  }
}
// 4. EDIT: Add PhotosList to AlbumDetail's render()
class AlbumDetails extends Component {
  render() {
    return (
      &lt;Segment&gt;
        &lt;Header as='h3'&gt;{this.props.album.name}&lt;/Header&gt;
        &lt;S3ImageUpload albumId={this.props.album.id}/&gt;        
        &lt;PhotosList photos={this.props.album.photos.items} /&gt;
      &lt;/Segment&gt;
    )
  }
}</code></pre><p>如果你现在刷新你的应用，你应该会看到为你正在查看的相册加载的照片。呜！如果你添加了新的照片，等待Lambda函数被S3调用，然后刷新，你的新照片应该也可以看到了。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/59499948c9264a5a779986950ea10f76.png" alt="" class="wp-image-42766" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_tWW36mTkr6M6PbwDZcSJTw.png"/><figcaption>Viewing an album after uploading some photos</figcaption></figure></div><p id="ff5a">此时，关于我们的照片列表体验，有三件事值得讨论:</p><ul><li>为了看到新照片而刷新相册视图并不是一个很好的用户体验，但是这篇文章已经介绍了相当多的内容，下一篇文章还会介绍更多内容。简而言之，处理这个问题的方法是让我们的photo_processor Lambda函数触发API上的一个突变，并让AlbumDetailsLoader组件订阅这个突变。然而，因为我们使用Amazon Cognito用户池身份验证，让我们的Lambda函数触发这种变异的唯一方法是创建一种“系统”用户(通过正常的用户注册和确认过程)，安全地存储该用户的凭证(可能在<a href="https://aws.amazon.com/secrets-manager/" target="_blank" rel="noreferrer noopener"> AWS Secrets Manager </a>中)，并在我们的Lambda中以该用户的身份向我们的AppSync API进行身份验证，以便触发变异。</li><li>如果一个相册中有很多照片，我们的API不会在第一个<code>getAlbum</code>查询中返回所有照片。相反，我们需要增强我们的<code>AlbumDetails</code>组件，以允许用户对旧照片进行分页，按需加载更多内容。我们将在下一篇文章中讨论这个问题。</li><li>我们目前只渲染每张照片的缩略图。当你点击一张照片时，显示它的完整尺寸可能会很好。我将把这些改进留给读者作为练习。🙂</li></ul><h3 id="2f7b">接下来</h3><p id="b342">在这篇文章中，我们已经讨论了很多内容。我们向React应用程序添加了路由，创建了用于加载和呈现相册细节、将照片上传到相册以及在相册中显示照片的组件。我们制作了一个AWS Lambda函数来为我们的照片自动创建缩略图，并且我们学习了如何使用SAM CLI打包和部署Lambda。<br/> <br/>在本系列的<a href="https://read.acloud.guru/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-bcaeba942159" target="_blank" rel="noreferrer noopener">下一篇(也是最后一篇)</a>文章中，我们将改进照片的列表和分页体验，为我们的相册添加细粒度的安全性，并且我们将了解如何将我们的应用部署到CDN，以在全球范围内加快加载速度。</p><p id="9561">如果你想在新帖子发布时得到通知，请在Twitter上关注我:<a href="https://medium.com/@gabehollombe" target="_blank" rel="noreferrer noopener"> Gabe Hollombe </a>。如果你对这篇文章有任何问题或反馈，这也是联系我的最好方式。</p><p id="5c0e"><a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part1" target="_blank" rel="noreferrer noopener"> <strong> <em>第一部分</em> </strong> </a> <strong> <em> |第二部分| </em> </strong> <a href="https://acloudguru.com/blog/engineering/build-your-own-multi-user-photo-album-app-with-react-graphql-and-aws-amplify-part3" target="_blank" rel="noreferrer noopener"> <strong> <em>第三部分</em> </strong> </a> <em> <br/>这是一个由三部分组成的系列文章的第二篇，向您展示如何在AWS上构建一个可扩展的、高度可用的无服务器web应用程序，允许用户将照片上传到相册并与他人私下共享这些相册。</em></p><h3 id="3e7a">启动我们到目前为止所建立的</h3><p id="69c7">如果你想检查一个回购并启动我们到目前为止构建的应用程序，请在GitHub上检查这个回购并使用blog-post-part-one标签，链接如下:<a href="https://github.com/gabehollombe-aws/react-graphql-amplify-blog-post/tree/blog-post-part-two" target="_blank" rel="noreferrer noopener">https://GitHub . com/gabehollombe-AWS/react-graph QL-amplify-blog-post/tree/blog-post-part-two</a>。按照自述文件中的步骤配置和启动应用程序。</p></div></div>    
</body>
</html>