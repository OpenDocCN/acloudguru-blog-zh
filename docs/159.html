<html>
<head>
<title>How the Saga Pattern manages failures with AWS Lambda and Step Functions | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Saga模式如何使用AWS Lambda和阶跃函数管理故障</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/how-the-saga-pattern-manages-failures-with-aws-lambda-and-step-functions#0001-01-01">https://acloudguru.com/blog/engineering/how-the-saga-pattern-manages-failures-with-aws-lambda-and-step-functions#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p id="h-in-the-world-of-microservices-it-s-important-to-ensure-data-consistency-is-maintained-across-distributed-transactions">在微服务领域，确保分布式事务之间的数据一致性非常重要。</p><p id="d9b6">在埃克托·加西亚-莫利纳<a href="http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" target="_blank" rel="noreferrer noopener"> 1987年的论文“<em>Sagas</em></a><em/>中，他描述了一种解决长时间运行的数据库事务中的系统故障的方法。</p><p>赫克托将传奇描述为一系列相关的小交易。在Saga中，协调者(在他们的例子中是数据库)确保所有涉及的事务都成功完成。否则，如果事务失败，协调器运行补偿事务来修改部分执行。</p><p id="1bfd">这种方法在<a href="https://acloudguru.com/blog/engineering/evolution-of-business-logic-from-monoliths-through-microservices-to-functions">微服务的世界中越来越重要，因为应用逻辑</a>经常需要跨多个有界上下文进行事务处理——每个上下文都由自己的微服务封装，具有独立的数据库。</p><p id="6486">Caitie McCaffrey 最近分享了一个很棒的演示，总结了她在分布式系统中使用Saga模式的经验。</p>  <p>在演示过程中，财经用下面一组关联交易的例子来说明这种模式。</p><pre class="wp-block-code"><code>Begin transaction
    Start book hotel request
    End book hotel request
    Start book flight request
    End book flight request
    Start book car rental request
    End book car rental request
End transaction</code></pre><h2 id="h-coordinating-the-saga">协调传奇故事</h2><p>我们可以使用一个Lambda函数来建模每个动作——以及它们的补偿动作——并在<a href="https://acloudguru.com/blog/engineering/processing-an-arbitrary-number-of-jobs-with-aws-step-functions"> AWS步骤函数</a>中使用一个状态机作为整个事件的<strong>协调器</strong>。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/593670583f6001f8e1d506e044152c36.png" alt="" class="wp-image-42045" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_z55cPiAQfE7oo028HYmdPw.png"/><figcaption>Each action and compensating action are modelled as a Lambda function.</figcaption></figure><p id="377f">由于补偿动作也可能失败，我们需要能够重试它们直到成功——这意味着它们必须是<strong>幂等的</strong>。我们还将在系统出现故障时实现<strong>向后恢复</strong>。</p><p id="6603">下面是代表我们故事的状态机。每个操作——预订酒店、预订航班和预订租赁——都有一个补偿操作，并将按顺序执行。递归箭头表示补偿动作被重试，直到成功。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/ba08758c5dfdb3fbb197bd947d1542cb.png" alt="The state machine that represents a saga pattern." class="wp-image-42040" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_aXLVIRiSAeAeEfRh4ZpArQ.png"/></figure><p>每个Lambda函数都希望输入为以下形式:</p><pre class="wp-block-code"><code>{
  "trip_id": "5c12d94a-ee6a-40d9-889b-1d49142248b7",
  "depart": "London",
  "depart_at": "2017-07-10T06:00:00.000Z",
  "arrive": "Dublin",
  "arrive_at": "2017-07-12T08:00:00.000Z",
  "hotel": "holiday inn",
  "check_in": "2017-07-10T12:00:00.000Z",
  "check_out": "2017-07-12T14:00:00.000Z",
  "rental": "Volvo",
  "rental_from": "2017-07-10T00:00:00.000Z",
  "rental_to": "2017-07-12T00:00:00.000Z"
}</code></pre><p id="f751">每个函数内部都有一个针对不同DynamoDB表的简单的<code>PutItem</code>请求。相应的补偿函数将对相应的表执行一个<code>DeleteItem</code>来回滚<code>PutItem</code>动作。</p><p id="c13b">状态机依次将相同的输入传递给每个动作(预订酒店→预订航班→预订租赁),并记录它们在特定路径的结果。这将避免覆盖将传递给下一个函数的输入<code>$</code>。</p><p id="bffa">在这个简单的实现中，我们将对任何失败应用补偿操作——因此有了下面的<code>State.ALL</code>。在实践中，您应该考虑给某些错误类型一个<a href="http://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-errors.html#amazon-states-language-retrying-after-error" target="_blank" rel="noreferrer noopener">重试</a> —例如，暂时性错误，如DynamoDB的供应吞吐量超出异常。</p>  <p>每个动作和补偿动作的输出和错误都存储在特定的路径中。这将避免覆盖其余动作的输入值<code>$</code>。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/b965613464a8a7eb1e955a23ed12e21d.png" alt="The output and error from each action and compensating action are stored at a specific path." class="wp-image-42041" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_gvZthJIJnu1RuR5LESD3WA.png"/></figure><h3 id="7389">快乐之路流动</h3><p id="aa5d">沿着这条快乐的道路，每个动作依次执行，状态机将成功完成。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/f8eedb75187c63beed2d9b5b4a5a7bcc.png" alt="Saga path where each of the actions are performed in turn and the state machine will successfully complete." class="wp-image-42042" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_imuQ-fwnzAVE4a3xgLvsyg.png"/></figure><h3 id="304b">失败案例</h3><p id="3736">当故障发生时，我们需要根据故障发生的位置依次采取相应的补偿措施。</p><p id="9689">在下面的例子中，如果失败发生在<code>BookFlight</code>，那么<code>CancelFlight</code>和<code>CancelHotel</code>都将被执行，以回滚到目前为止所执行的任何更改。</p><p id="30cb">类似地，如果失败发生在<code>BookRental</code>，那么所有三个补偿动作——<code>CancelRental</code>、<code>CancelFlight</code>和<code>CancelHotel</code>——将按顺序执行，以回滚事务的所有状态改变。</p><p id="3a3d">每个补偿动作也有一个无限的重试循环！实际上，在提醒人为干预之前，重试次数应该有一个合理的上限。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/255093ca78078d639c233d6779e8be4a.png" alt="Showing each compensating action having an infinite retry loop." class="wp-image-42044" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_xi8bWmKy9nIn7j2vgnmKKQ.png"/></figure><p id="b170">如果你想用这个例子自己试验Saga模式，这里是这个演示的源代码。</p><p id="873c">我很想知道你对使用Saga模式和微服务架构的优缺点的看法…请在下面留言。<em>感谢阅读！</em></p><hr class="wp-block-separator is-style-wide"/><h2 class="has-text-align-center" id="h-get-the-skills-you-need-for-a-better-career">获得更好职业所需的技能。</h2><p class="has-text-align-center">掌握现代技术技能，获得认证，提升您的职业生涯。无论您是新手还是经验丰富的专业人士，您都可以通过实践来学习，并在ACG的帮助下推进您的云计算职业生涯。</p><hr class="wp-block-separator is-style-wide"/></div></div>    
</body>
</html>