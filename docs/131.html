<html>
<head>
<title>Serving dynamic website content with serverless architecture | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用无服务器架构提供动态网站内容|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/serving-dynamic-website-content-with-serverless-architecture#0001-01-01">https://acloudguru.com/blog/engineering/serving-dynamic-website-content-with-serverless-architecture#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p>网页内容通常是静态或动态的。静态内容是提供给每个访问者的相同内容，而动态内容是变化的。一些世界上最繁忙的网站是基于动态内容的，比如有标题列表的新闻网站，或者有最新交易的电子商务网站。</p><p>要使用传统的基于服务器的web应用程序提供动态内容，通常服务器脚本或应用程序会从数据库获取结果并呈现页面。扩展这种设计以服务大量的访问者可能是具有挑战性的。每个页面视图都需要web服务器查询数据库并将结果呈现给读者。对于大流量，这会增加服务器和数据库的负载。</p><p>对于使用<a href="https://acloudguru.com/hands-on-labs/provisioning-a-lamp-stack-with-vagrant"> LAMP stack架构</a>的站点，比如WordPress，或者其他基于服务器的web应用程序，你可以采用一种混合的无服务器方法来提供这种功能。这有助于加速开发，使其更容易扩展，并促进基于<a href="https://acloudguru.com/blog/engineering/using-your-first-microservice-with-aws-lambda">微服务的模型</a>。</p><p>一个<a href="https://acloudguru.com/course/serverless-concepts">无服务器架构</a>可以通过使用专为扩展而设计的服务，更轻松地为每秒数以千计的访问者提供服务。在混合方法中，它也不改变现有的服务器代码或数据库模式。在这篇博文中，我解释了如何使用最少的定制代码构建高度可伸缩的解决方案来提供动态内容。</p><h2 id="h-overview">概观</h2><p>虽然您可以使用无服务器技术来构建<a href="https://github.com/aws-samples/happy-path/">整个网络应用</a>，但是您也可以使用基于微服务的后端来为现有网站带来动态功能。</p><p><a href="https://serverlessland.com/whats-new">无服务器之地</a>网站使用这种方法为访问者生成动态结果。在该网站上，<a href="https://serverlessland.com/whats-new">新功能</a>页面聚集了来自十几个不同AWS服务的功能发布信息。后端服务从公共RSS提要收集这些信息，然后前端从公共端点获取数据。当访问者导航到该站点时，他们会看到一个检索汇总结果的页面:</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/0fc7e9522e2a86566ba4f56fab53e387.png" alt="" class="wp-image-52136" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1305/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png 1305w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1024/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png 1024w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png 768w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_380/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png 380w" sizes="(max-width: 1305px) 100vw, 1305px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image001.png"/></figure><p>无服务器架构</p><h2 id="h-the-serverless-architecture">该解决方案使用两个独立的微服务。一种是按计划从外部数据源获取数据，并将结果存储在数据库中。另一个服务于前端web应用程序，从数据库获取结果。架构看起来是这样的:</h2><p>The solution uses two separate microservices. One fetches the data on a schedule from external data sources and stores the result in a database. The other serves the frontend web application, fetching the results from the database. The architecture looks like this:  </p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/951b9a0a059afb8a33b0bd7b7fca3c61.png" alt="" class="wp-image-52139" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_774/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image003.png 774w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image003.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image003.png 768w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_380/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image003.png 380w" sizes="(max-width: 774px) 100vw, 774px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image003.png"/></figure><p>一个<a href="https://aws.amazon.com/eventbridge/"> Amazon EventBridge </a>预定规则每小时运行一次来调用一个Lambda函数。</p><ol><li><a href="https://aws.amazon.com/lambda/"> AWS Lambda </a>函数从外部数据源获取新数据，并过滤要保存的记录。</li><li>该函数将项目写入一个<a href="https://aws.amazon.com/dynamodb/"> Amazon DynamoDB </a>表。</li><li>网站前端调用一个<a href="https://aws.amazon.com/cloudfront/">亚马逊CloudFront </a>发行版的URL。缓存设置为5分钟。</li><li>每当缓存为空或过期时，CloudFront都会从API网关端点获取最新的内容。</li><li><a href="https://aws.amazon.com/api-gateway/">亚马逊API网关</a>调用第二个λ函数。</li><li>Lambda函数从DynamoDB表中加载数据。</li><li>部署示例</li></ol><h2 id="h-deploying-the-example">这个示例使用<a href="https://aws.amazon.com/serverless/sam/"> AWS无服务器应用程序模型</a> (AWS SAM)将解决方案部署到您的AWS帐户。要开始，你需要安装<a href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"> AWS CLI </a>和<a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html"> AWS SAM </a>。您还需要一个<a href="https://portal.aws.amazon.com/billing/signup"> AWS帐户</a>，但是这里显示的一切都可以在<a href="https://aws.amazon.com/free/"> AWS自由层</a>中部署和测试。</h2><p>要部署此示例:</p><p>从样本库中克隆代码:<br/> <code>git clone https://github.com/aws-samples/serverless-content-service-from-rss</code> <br/></p><ol><li>更改目录:<br/> <code>cd ./serverless-content-service-from-rss</code> <br/></li><li>运行AWS SAM build下载并安装使用的依赖项:<br/> <code>sam build</code> <br/></li><li>要将应用程序部署到您的AWS帐户，请运行AWS SAM guided deploy: <br/> <code>sam deploy –guided</code> <br/></li><li>部署向导会提示您一系列问题。输入您的首选堆栈名称、AWS区域，并允许AWS SAM创建API，而无需定义授权。<br/></li><li>The deployment wizard prompts you with a series of questions. Enter your preferred stack name, AWS Region, and allow AWS SAM to create the API without authorization defined.<br/> </li></ol><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/d2d77ca293660aa9a5eebb72c049e784.png" alt="" class="wp-image-52142" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_744/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image005.png 744w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image005.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_380/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image005.png 380w" sizes="(max-width: 744px) 100vw, 744px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image005.png"/></figure><p>随着应用程序的部署，EventBridge调度规则每小时调用一次<em> Import </em> Lambda函数。这将从一个公共RSS提要中获取数据，并将项目存储在应用程序的DynamoDB表中。</p><p>了解AWS SAM模板</p><h2 id="h-understanding-the-aws-sam-template">repo中的<a href="https://github.com/aws-samples/serverless-content-service-from-rss/blob/main/template.yaml">模板</a>定义了该应用程序使用的所有资源。首先，它使用<a href="https://aws.amazon.com/dynamodb/pricing/on-demand/">按需容量模式</a>声明一个带有分区键和排序键的DynamoDB表:</h2><p>接下来，模板定义了<em> Import </em> Lambda函数。它将内存大小设置为128 MB，将运行时设置为Node.js 14。RSS提要URL是作为函数的环境变量提供的，因此您可以根据自己的需要在这里更新它，而无需更改Lambda函数中的代码:</p><pre class="wp-block-code"><code>DDBtable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: PK
        AttributeType: S
      - AttributeName: SK
        AttributeType: N
      KeySchema:
      - AttributeName: PK
        KeyType: HASH
      - AttributeName: SK
        KeyType: RANGE
      BillingMode: PAY_PER_REQUEST</code></pre><p>这使用了一个<a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-templates.html"> AWS SAM策略模板</a>来授予对模板的DynamoDB表的权限。AWS SAM自动提供调用该功能并将日志保存到<a href="https://aws.amazon.com/cloudwatch/"> Amazon CloudWatch </a>的最小权限。在<em>事件</em>中，模板使用<a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html"> EventBridge预定规则</a>定义了每小时一次的调用。这两个部分定义了第一个微服务按计划获取数据并将结果存储在DynamoDB中所需的一切。</p><pre class="wp-block-code"><code>ImportFunction:
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 10
      CodeUri: parser/
      Handler: app.handler
      Runtime: nodejs14.x
      MemorySize: 128
      Environment:
        Variables:
          Feed: 'https://aws.amazon.com/about-aws/whats-new/recent/feed/'
          TableName: !Ref DDBtable        
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref DDBtable        
      Events:
        EventBridgeSchedule:
          Type: Schedule
          Properties:
            Schedule: 'rate(1 hour)'
            Name: ImportSchedule
            Enabled: True</code></pre><p>第二个微服务为客户端应用程序创建一个HTTP端点来获取项目。该模板定义了API网关端点和Lambda函数:</p><p>在<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html">HTTP API</a>配置中，这定义了一个开放的<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html"> CORS配置</a>用于测试和开发目的。在生产应用程序中，您应该相应地确定这种访问的范围。Lambda函数的事件处理程序配置API路径和方法。</p><pre class="wp-block-code"><code>MyApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      CorsConfiguration:
        AllowMethods:
          - GET
          - POST
          - DELETE
          - OPTIONS
        AllowHeaders:
          - "*"   
        AllowOrigins: 
          - "*"      

  GetItems:
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 3
      CodeUri: getItems/
      Handler: app.handler
      Runtime: nodejs14.x
      MemorySize: 128
      Environment:
        Variables:
          TableName: !Ref DDBtable        
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref DDBtable        
      Events:
        UploadAssetAPI:
          Type: HttpApi
          Properties:
            Path: /items
            Method: get
            ApiId: !Ref MyApi</code></pre><p>最后，模板定义了CloudFront发行版。这使用API网关端点作为起点，并将<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">生存时间</a> (TTL)值设置为300秒:</p><p>测试应用程序</p><pre class="wp-block-code"><code> CloudFront:  
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        IPV6Enabled: true
        HttpVersion: http2
        Comment: !Ref 'AWS::StackName'
        Origins:
        - Id: APIGOrigin
          DomainName: !Sub ${MyApi}.execute-api.${AWS::Region}.amazonaws.com
          CustomOriginConfig:
            HTTPSPort: 443
            OriginProtocolPolicy: https-only
        DefaultCacheBehavior:
          AllowedMethods: ["GET", "HEAD"]
          CachedMethods: ["GET", "HEAD"]
          ForwardedValues:
            Headers:
            - Access-Control-Request-Headers
            - Access-Control-Request-Method
            - Origin
            QueryString: true
          TargetOriginId: APIGOrigin
          ViewerProtocolPolicy: https-only
          Compress: true
          DefaultTTL: 300</code></pre><h2 id="h-testing-the-application">随着后端的部署，<em> Import </em>函数每小时获取一次新内容。您也可以在<a href="https://console.aws.amazon.com/lambda/home"> Lambda控制台</a>中手动运行该功能以立即获取内容。</h2><p>运行<code>sam deploy</code>命令后，堆栈中的<a href="https://aws.amazon.com/cloudformation/"> AWS CloudFormation </a>输出显示了您的发行版的基本URL:</p><p>After running the <code>sam deploy</code> command, the <a href="https://aws.amazon.com/cloudformation/">AWS CloudFormation</a> outputs from the stack show the base URL for your distribution: </p><p>完整的端点是附加了“/items”路径的基本URL。您可以使用类似于<a href="https://curl.se/"> curl </a>或<a href="https://www.postman.com/"> Postman </a>的工具来查询这个url，并查看返回的项目列表:</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/5eb7b2c7fc397060ac697f22b3159128.png" alt="" class="wp-image-52147" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_593/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image007.png 593w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image007.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_380/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image007.png 380w" sizes="(max-width: 593px) 100vw, 593px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image007.png"/></figure><p>The complete endpoint is the base URL with the ‘/items’ path appended. You can use tools like <a href="https://curl.se/">curl</a> or <a href="https://www.postman.com/">Postman</a> to query this URL and see the list of items returned:</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/941dc5d598469ff66c7f6e53ed2f4c7e.png" alt="" class="wp-image-52149" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1134/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png 1134w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1024/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png 1024w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png 768w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_380/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png 380w" sizes="(max-width: 1134px) 100vw, 1134px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/06/image008.png"/></figure><p>与web应用程序集成</p><h2 id="h-integrating-with-a-web-application">为了让web应用程序使用这个后端，它必须对前一个端点进行API调用。这个过程使用JavaScript直接从浏览器前端调用端点。在React、Vue.js或Angular等单页面应用程序框架中，可以设置页面组件在页面首次加载时调用端点。</h2><p>无服务器的Land网站是用Vue.js编写的，下面的代码片段展示了页面上的组件实例如何在<a href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#mounted">挂载的生命周期钩子</a>中进行API调用。<em>launchs _ URL</em>变量包含从CloudFront发行版中获取项目列表的URL:</p><p>目前，这将返回最近的100个结果。在高级实现中，API还可以通过查询参数支持搜索和分页。您可以使用底层DynamoDB表中的sort键按照时间戳对结果进行排序。</p><pre class="wp-block-code"><code>const axios = require('axios')
const ITEMS_URL = 'https://d11abcdef12345.cloudfront.net/items

export default {
  data () {
    return {
      items: [],
    }
  },
  mounted: async function() {
    // Load dynamic data from backend service
    const result = await axios.get(ITEMS_URL)
    this.items = result.data.Items
  }
}</code></pre><p>配置CloudFront缓存</p><h2 id="h-configuring-cloudfront-caching">在这个解决方案中，前端web应用程序可以直接调用API网关端点并接收相同的响应。然而，在繁忙的web应用程序中，这会导致对API Gateway的大量调用，而API Gateway又会调用Lambda和DynamoDB。因为动态项目列表可能很少改变，所以您可以使用CloudFront来缓存结果，改善延迟，并降低总成本。</h2><p>在本例中，<em>导入</em>功能每小时运行一次。您可以安排轮询过程以更短的时间间隔运行，例如每分钟一次。根据工作负载的需要，您可以在短至一秒的时间内定制<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html"> CloudFront TTL值</a>。</p><p>实时网站使用五分钟的缓存。如果有大量的站点访问者到达，大多数请求都由CloudFront发行版处理。只有当缓存过期或现有缓存为空时，CloudFront才会调用API网关端点。</p><p>结论</p><h2 id="h-conclusion">动态网页内容可以让你的网站对访问者更有用。它通常用于提供功能，如最新的电子商务交易、最近的客户评论或您产品的最新功能发布。</h2><p>使用传统的基于服务器的方法，这会增加web服务器和底层数据库的负载。横向扩展或处理峰值工作负载也是一项挑战。</p><p>这篇博文展示了一种支持高吞吐量的无服务器方法。这使用了一个微服务，它获取数据并将结果存储在DynamoDB表中。客户端应用程序调用一个CloudFront分发端点，该端点使用另一个微服务从表中获取项目。</p><p>如需更多无服务器学习资源，请访问<a href="https://serverlessland.com/whats-new">无服务器世界</a>。</p><p>For more serverless learning resources, visit <a href="https://serverlessland.com/whats-new">Serverless Land</a>.</p></div></div>    
</body>
</html>