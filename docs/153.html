<html>
<head>
<title>Streaming Video at Scale: A Tale of Transcoding | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>大规模流媒体视频:代码转换的故事</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/streaming-video-at-scale-a-tale-of-transcoding-at-acg#0001-01-01">https://acloudguru.com/blog/engineering/streaming-video-at-scale-a-tale-of-transcoding-at-acg#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p><a href="https://acloudguru.com/blog/engineering/easy-video-transcoding-in-aws">视频转码</a>在我们学生使用云计算大师平台的体验中发挥了巨大作用。我们来自世界各地的学习者可以在他们的桌面、平板电脑或我们的移动应用程序上观看我们的内容。</p><p>还有相当多的云学习内容需要观看。现在，我们有340门课程，包含11，050个单独的课程。此外，还有26个网络系列，包含503个单独的系列视频。我们最近增加了动手实验内容，因此在此基础上又增加了大约1，500个视频。我们定期更新我们的目录。每个视频的长度从2到20分钟不等。视频内容真多啊！</p><p>在这篇文章中，我将分享我们如何处理代码转换的故事，看看从最开始到当前的实现是如何完成的。我们将探讨我们在此过程中遇到的问题和权衡，以及如何改进我们当前的解决方案。</p><figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><p class="wp-block-embed__wrapper"> </p></figure><p/><h2 id="h-but-what-even-is-transcoding">但是什么是代码转换呢？</h2><p>我听到你问，“为什么它很重要？”从很高的层面上来说，视频转码是将视频从其原始格式转换为另一种格式的过程，通常是将其缩小到更适合终端设备的格式或分辨率。该过程本身包括将视频文件从一种格式解码为未压缩格式，然后将未压缩数据编码为所需格式。</p><p>那么，为什么我们需要不同的视频格式和分辨率呢？我们希望能够在多种设备上兼容观看我们的内容，包括PC、平板电脑、手机、智能冰箱等等。更重要的是，我们希望确保我们的用户能够在他们使用的任何设备上获得最佳的观看体验。</p><p>你可以想象一个ACG的学习者试图在一个低连接的地区用手机观看一个高清视频<a rel="noreferrer noopener" href="https://acloud.guru/overview/intro-aws-cloudformation" target="_blank">云形成要点</a>会有一个非常糟糕的体验！</p><p>因此，我们拥有的选项越多，我们可以接触到的设备和用户就越多，每个人的体验也就越好。</p><h2 id="h-how-did-we-do-it-in-the-beginning">我们一开始是怎么做的？</h2><p>当然，一个云专家并没有一开始就有这么多的视频内容，而且我们当时也没有移动应用程序。</p><p>最开始，<em>回到2015年</em>，视频转码是一个手动过程。该团队会上传一个视频到一个名为手刹的程序，应用程序会对视频进行转码。</p><p>不用说，不久就需要一种新的方法！</p><h2 id="h-introducing-aws-elastic-transcoder"><strong>介绍AWS弹性转码器</strong></h2><p>我们是一家运行在亚马逊网络服务(AWS)上的无服务器商店，所以利用弹性转码器(AWS在云中的媒体转码器)是非常明智的。它是AWS的第一个代码转换服务，现在已经在很多应用程序中使用。</p><p>与手刹一样，它将媒体文件从一种格式转换成可以在不同设备上播放的各种不同格式。</p><p>Elastic Transcoder还为流行的输出格式提供了转码预设，因此您无需猜测哪些设置在特定设备上效果最佳。因此，无论是iPhone、三星、Kindle还是其他什么，它都迎合了这些设备的需求。</p><p>同年(2015年)，对转码流程进行了改造。最初的过程完全是手动的，是时候实现自动化了！</p><p>通常，我们平台上的内容创建者需要转换至少1080p(全高清分辨率)的mp4视频。当用户在桌面上观看我们的视频时，质量默认设置为720p，这是标准的高清。我们还提供1080p和更低的480p作为播放选项。</p><h3 id="h-how-did-our-first-implementation-work">我们的第一次实施效果如何？</h3><ol><li>我们的内容团队将从编辑器UI上传一个MP4文件，并将其添加到我们的S3输入桶中。文件名中包含数据编码，因此看起来可能是这样的:<em>course/AWS-CsA/section-1/component-1 . MP4</em><br/><br/>文件名按课程、课程名称、部分和组件分类，因为您可能有多个视频组成一门课程的不同部分。</li></ol><ol start="2"><li>上传到输入存储桶将触发lambda函数，该函数由输入S3存储桶中的ObjectCreated事件触发。<br/></li><li>lambda将向Firebase写下处理状态，表示已经为该文件启动了新的代码转换作业。<br/></li><li>然后，lambda会将S3对象密钥作为输入传递给弹性代码转换器，以处理mp4。<br/></li><li>Elastic Transcoder会将转码后的视频以我们指定的格式放入输出桶中。重要的是要注意，在这一点上，我们想要转码的配置在我们的源代码中是固定的。</li></ol><ol start="6"><li>然后，我们有一个lambda，它将由输出桶中的ObjectCreated事件触发，该事件将使用代码转换作业的状态“完成”来更新Firebase。<br/></li><li>在整个过程中，数据被重新同步到浏览器(Firebase有websockets)。当代码转换器在后台工作时，状态在Firebase中更新，然后Firebase将状态推送到浏览器。<br/></li><li>最后，对于任何在平台上观看的学习者，他们将通过一个签名的URL访问内容。他们会看1080p、780p或480p的mp4。</li></ol><h3 id="h-problems-with-this-approach"><strong>这种方法的问题</strong></h3><p id="h-at-this-point-in-time-we-were-introducing-web-series-and-this-architecture-is-tightly-coupled-to-courses-and-firebase-we-knew-we-wanted-to-have-different-types-of-content-aside-from-course-videos-and-this-solution-isn-t-generic">在这个时候，我们正在引入web系列，这个架构与Courses和Firebase紧密耦合。我们知道，除了课程视频之外，我们还需要不同类型的内容，这个解决方案并不通用。</p><p>另一个问题是数据被编码到文件名中。因此，这个实现将基于文件名在服务中传递数据。这是它知道文件与特定课程中的特定视频相关的方式。这就是Firebase层次结构是如何确定的，它与具体的课程紧密耦合。</p><p>S3支持元数据，所以我们可以通过键值对作为元数据添加这些数据，而不是从文件名中提取。视频预置被硬编码到源代码中，所以我们不能在整个过程中添加任意数据。如果我们想用不同的配置对视频进行转码，我们不能这样做，因为预置在源代码中是固定的。</p><p>我们也没有DynamoDB来查找或存储任何额外的数据——实际上你所拥有的只是在lambda函数中传递的文件名。</p><h3 id="h-how-did-we-move-away-from-this">我们是如何摆脱这种局面的？</h3><p>我们知道我们想要不同类型的内容，并且之前的设计将课程与Firebase紧密耦合，所以我们决定将内容的类型分离。现在，我们为网络系列和课程提供了不同的服务，还有一个进行代码转换的内容服务。</p><p>内容服务本身是通用的。它不知道视频内容是连续剧还是课程材料，也不知道连续剧还是课程服务，它只关注转码工作。</p><p>浏览器将调用内容服务，通过上传视频进行代码转换来创建一段内容，内容服务将返回一个contentID。根据内容，该contentID将与网络系列服务中的一集或课程服务中的一节相关联。</p><h3 id="h-a-peek-into-the-content-service"><strong>窥探内容服务</strong></h3><p>图中的内容服务是一个带有GraphQL端点的服务，它触发lambdass，然后lambda根据请求与特定的AWS服务对话。我在这里用GraphQL标识来表示它。</p><p>在内容编辑器UI中，我们首先通过GraphQL变体/API创建一段内容，这将触发一个处理程序将这段内容写入DynamoDB。通过这个API调用，我们能够指定我们想要的视频定义/格式。比如我们可以通过720p，1080p，mp3等。而在之前的实现中，这个细节是在源代码中硬编码的。</p><p>接下来，内容服务创建一个预签名的URL，这样内容只能由内容编辑上传到S3输入桶中。</p><p>现在，我们做代码转换！</p><ol><li>向Elastic Transcoder发送请求以启动作业，对内容进行代码转换。</li></ol><ol start="2"><li>Elastic Transcoder从S3输入桶中获取被请求转码的视频，并在作业完成后将转码后的视频文件放入S3输出桶中。<br/> <br/>随着代码转换过程的进行，Elastic Transcoder使用作业状态更新DynamoDB表，因为它为您提供了作业的开始和结束事件。例如，一旦Elastic Transcoder完成了工作，它就会在SNS主题的有效负载中发送该状态。然后订阅该主题的lambda会去更新DynamoDB。<br/></li><li>发生这种情况时，浏览器会轮询更新，以便用处理状态更新UI。这取代了可用于Firebase的web套接字。我们现在已经从Firebase转移到DynamoDB，这是我们做出的权衡。</li></ol><p>4.一旦这项工作完成，转码后的文件将被放入S3输出桶，CloudFront将为视频内容提供签名的URL。这确保了我们的内容只对平台成员开放！</p><h2 id="h-problems-with-our-current-approach"><strong>我们当前方法的问题</strong></h2><p>这个解决方案的大部分是在云形成中，但不是全部！不幸的是，弹性代码转换器不是一个受支持的资源，所以我们不得不在控制台中手动设置它。</p><p>另外，弹性转码器服务现在已经过时了。有一个更新的服务我们可以用它来代替，我很快就会谈到它！</p><p>我们已经走了这么远，我们已经做出了改变，我们取得了什么成就？嗯，我们已经设法通过内容服务来集中我们所有的视频。每一点视频内容，不管它是为了什么(课程或网络系列，现在动手实验室)，都使用相同的接口进行转码。我们以前已经脱离了这种紧密耦合的解决方案。</p><h2 id="h-looking-to-the-future"><strong>展望未来</strong></h2><p>我们如何改进当前的实施？我提到的弹性转码器已经过时了。这是第一个能够转码视频的AWS服务，但现在有一个更新的服务可以取代它——AWS Elemental media convert。</p><p>MediaConvert可以做和弹性转码器一样的事情，甚至更多！它支持更多的输入和输出格式，以及HEVC和H.264压缩标准(Elastic Transcoder仅支持H.264)和其他新功能，包括视频质量改进、编解码器和其他附加功能。</p><p>它在CloudFormation中可用，所以我们将能够有一个完整的IaC解决方案，这太棒了！您可以在Cloud Formation中生成转码作业，以及队列和预置。</p><p>MediaConvert的定价模式类似于弹性转码器，因此您可以按需购买，按需付费。并且速率基于输出视频的持续时间。使用MediaConvert要便宜得多，这对我们每个月的代码转换账单肯定有帮助！</p><p>我们现在已经为我们的内容提供了有效的代码转换服务，希望MediaConvert在不久的将来能够锦上添花！</p></div></div>    
</body>
</html>