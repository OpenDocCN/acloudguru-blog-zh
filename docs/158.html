<html>
<head>
<title>How long does AWS Lambda keep your idle functions around before a cold start? | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在冷启动之前，AWS Lambda会将您的闲置功能保留多长时间？|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/how-long-does-aws-lambda-keep-your-idle-functions-around-before-a-cold-start#0001-01-01">https://acloudguru.com/blog/engineering/how-long-does-aws-lambda-keep-your-idle-functions-around-before-a-cold-start#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p><strong> AWS Lambda通常会在45-60分钟的不活动状态后终止功能，尽管空闲功能有时会提前终止，以释放其他客户所需的资源。</strong></p><p id="0d8a">在最近的一次实验中，我比较了使用不同语言、内存分配和部署包大小的AWS Lambda的冷启动时间。</p><p id="0d8a">当<a href="https://acloudguru.com/blog/engineering/packaging-aws-lambda-functions-as-container-images"> AWS Lambda函数</a>在长时间未使用后被调用，导致调用延迟增加时，发生冷启动。</p><p id="f582">一个有趣的观察结果是，功能在5分钟不活动后不再循环——这使得冷启动远没有那么糟糕。</p><p>了解语言、内存和封装大小如何影响AWS Lambda的冷启动。<a href="https://acloudguru.com/blog/engineering/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda?utm_source=medium_blog&amp;utm_medium=redirect&amp;utm_campaign=medium_blog">比较使用不同语言</a>、内存分配和部署规模的AWS Lambda的冷启动时间。</p><h2 id="h-lambda-timeout-experiment">λ超时实验</h2><p id="cbed">在实验过程中，我的一些功能直到30分钟的空闲时间后才经历冷启动。更长时间的不活动是亚马逊在幕后悄悄改变的——这是一个好消息。然而，这一变化促使我提出了几个后续问题:</p><ol><li>触发冷启动的新的不活动期是什么？</li><li>内存分配会影响冷启动前的空闲时间吗？</li></ol><p id="1ea9">为了满足我的好奇心，我设计了一个实验和假设。该实验旨在帮助我们了解AWS Lambda平台的实现细节。</p><p id="db4a">由于AWS可以——并且将会——在不事先通知的情况下更改这些实现细节，所以您不应该用这些结果来构建您的应用程序！</p><h4 id="0f8a">假设1</h4><p id="317b">在回收相关资源之前，Lambda允许你的函数保持空闲的时间是有上限的</p><p id="dc8d">这应该是必然的AWS永远保留闲置的功能是没有任何意义的。闲置功能占用的资源可用于帮助其他AWS客户扩大规模以满足他们的需求。对AWS来说，最重要的是，一个不活跃的功能不是支付账单。</p><h4 id="5ef2">假设2</h4><p id="0a3c"><em>空闲超时不是常数</em></p><p id="b82c">从开发人员的角度来看，冷启动前持续公布一段空闲时间更好，例如，功能总是在X分钟不活动后终止。</p><p id="c146">但是，AWS很可能会改变超时时间，以优化更高的利用率。这使他们能够在其物理服务器群中保持更均匀的性能水平。例如，如果某个地区的资源争用程度较高，AWS缩短冷启动时间并终止功能以释放资源是有意义的。</p><h4 id="dfc6">假设3</h4><p id="7d95"><em>不活动的上限因内存分配而异</em></p><p id="4098">具有1536 MB内存分配的空闲函数比具有128 MB内存的空闲函数浪费更多的资源。AWS提前终止内存分配较高的空闲函数是有意义的。</p><h4 id="665f">尝试寻找不活动的上限</h4><p id="d08b">为了找到不活动的上限，我们首先需要创建一个Lambda函数作为<code>system-under-test</code>来报告它何时经历了冷启动。</p><p id="bb92">然后，我们将需要一种机制来逐渐增加调用之间的间隔，直到我们到达一个地方，在那里每次调用都保证是冷启动——上界<em>。当间隔X分钟调用后观察到十(10)次连续冷启动时，确定上限值。</em></p><p id="08a3">为了回答假设3——内存的影响——我们还将使用不同的内存分配来复制<code>system-under-test</code>函数。</p><p id="77c8">这个实验是一个耗时的过程，它需要纪律和一定程度的时间精度。我只想说，我不会用手来做这件事！</p><h4 id="e1fa">设置实验的阶跃函数</h4><p id="5d9a">我的第一个方法是使用一个<a href="https://acloudguru.com/hands-on-labs/monitoring-and-notifications-with-cloudwatch-events-and-sns"> CloudWatch调度</a>来触发<code>system-under-test</code>函数，并让该函数根据它是否经历了冷启动来动态调整调度。</p><p id="b532">这种方法惨败。每当<code>system-under-test</code>更新时间表时，它立即触发，而不是等待新指定的时间间隔。</p><p id="37b2">相反，我向<em>阶跃函数</em>寻求帮助。</p><p id="bba2"><em> <a href="https://acloudguru.com/blog/engineering/processing-an-arbitrary-number-of-jobs-with-aws-step-functions"> AWS步骤函数</a> </em>允许您创建一个状态机，您可以在其中调用<em>函数、等待指定的时间、执行并行任务、重试、捕捉错误等等。</em></p><p id="fdfc">下面是用来进行这个实验的状态机。可视化工作流描述了FindIdleTimeout状态将如何调用<code>system-under-test</code>函数。根据它的输出，它要么完成实验，要么在递归之前等待。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/186d8c932164ae53f2df32bda73cefd5.png" alt="Visual workflow of AWS Lambda idle timeout." class="wp-image-42801" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_wgy1pXfr-F0B7oqHDEgLXg.png"/><figcaption>AWS Step Functions Visual Workflow</figcaption></figure></div><p><code>wait</code>状态允许你使用数据驱动等待的秒数——更多细节参见<a href="http://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-wait-state.html" target="_blank" rel="noreferrer noopener">文档</a>中的<code>SecondsPath</code>参数。<code>wait</code>状态允许我用这样的输入启动状态机:</p><pre class="wp-block-code"><code>{ 
    “target”: “when-will-i-coldstart-dev-system-under-test-128”, 
    “interval”: 600, 
    “coldstarts”: 0 
}</code></pre><ul><li>然后输入作为调用事件传递给另一个<code>find-idle-timeout</code>函数。</li><li>该函数将调用<code>target</code>——它是<code>system-under-test</code>函数的一个变体，具有不同的内存分配</li><li>如果<code>system-under-test</code>功能没有报告冷启动，它将增加间隔。</li><li>最后，<code>find-idle-timeout</code>函数将为<em>步骤函数</em>的执行返回一条新数据</li></ul><pre class="wp-block-code"><code>{ 
    “target”: “when-will-i-coldstart-dev-system-under-test-128”, 
    “interval”: 660, 
    “coldstarts”: 0 
}</code></pre><ul><li>此时，<code>wait</code>状态将使用<code>interval</code>值，并在切换回<code>FindIdleTimeout</code>状态之前等待<code>660</code>秒。</li><li>然后它将再次调用<code>find-idle-timeout</code>函数——使用之前的输出作为输入。</li></ul><pre class="wp-block-code"><code>"Wait": {
    "Type": "Wait",
    "SecondsPath": "$.interval",
    "Next": "FindIdleTimeout"
},</code></pre><p>有了这个设置，我可以开始多次执行——每次执行一个内存设置。使用Steps Functions仪表板，您可以观察状态机的活动执行。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/3a60e78bb6d16c3050c7714c8c8ea58a.png" alt="" class="wp-image-42802" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_xRYJA1wkZeRIPeaZ9zV5gA.png"/><figcaption>The Steps Functions Dashboard</figcaption></figure></div><p>一路上，我对正在发生的事情有了充分的了解，所有这些都来自舒适的<em>步骤功能</em>管理控制台。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/3893b9b9ad9e251906f39383bf7c2619.png" alt="The Step Functions management console to view the current state of the machine. " class="wp-image-42791" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_0P3gbFZdMa5xlFa5-fMT7Q.png"/><figcaption>The Step Functions Console</figcaption></figure></div><p>使用阶跃函数控制台，您还可以看到状态机的输入和当前输出。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/63f082f54d703af8fce4db24c035f857.png" alt="Execution details of inputs. " class="wp-image-42799" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_NOwTZRaut4jBFYOWlQ7eIg.png"/><figcaption>Execution Details: Input</figcaption></figure></div><p>第一次调用目标函数时，保证是冷启动。在这里，您可以看到当前冷启动计数为一(1)。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/eed8b954fe79f2e0f0b97746e3f38c74.png" alt="Execution details of outputs. " class="wp-image-42800" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_u39_qnPi1fL1QEVAr30pLw.png"/><figcaption>Execution Details: Output</figcaption></figure></div><p>使用阶跃函数控制台，您还可以看到状态转换何时发生，以及每次转换时的相关输入和输出。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/d736bfc5feb267f507a2fc0544667a66.png" alt="The Step Functions Console showing the state transitions  and the relevant inputs and outputs at each transition." class="wp-image-42793" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_06MIvNFE_apZXU5bhHmGtA.png"/><figcaption>State Transitions</figcaption></figure></div><h4 id="b6df">结果！</h4><p id="de3c">从数据来看，很明显AWS Lambda在整点左右关闭了空闲功能。有趣的是，1536 MB内存的功能提前10多分钟 <strong>终止<em>。</em></strong>这一发现支持假设3<em>——</em>内存分配较高的空闲函数会被较早终止。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/bc6b142e77d779df0ab10b8038d6857e.png" alt="The data showing AWS Lambda idle timeouts." class="wp-image-42798" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_NjZamQ0Utn2nUudiBm12lg.png"/></figure><p id="b613">为了帮助分析结果，我收集了所有冷启动的空闲时间间隔的数据，并将它们分成5分钟的类别。</p><p id="8e62">该表显示了在每个功能达到其上限空闲时间之前发生的冷启动次数<strong/></p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/21ccfd644c79dd6156c2fa60f48cbb51.png" alt="This table shows the number of cold starts that occurred before each function reached its upper bound Lambda idle time." class="wp-image-42794" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_ALY76AofOMRjcfmcjzBgEw.png"/></figure><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/f1b78abf92daf34e05e4ff83bbd20dfc.png" alt="Bar graph of coldstarts before reaching upper bound in minutes." class="wp-image-42792" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_3EQZkesfFga42t51Q-w64w.png"/></figure><p>从这个图表中，您可以看到超过60%的冷启动发生在45分钟之后——在功能达到其不活动上限之前。</p><p id="8555">尽管数据严重缺乏，但收集的少量数据仍然让我们观察到一些高水平的趋势:</p><ul><li>超过60%的冷启动发生在不活动45分钟之后——达到上限之前</li><li>具有1536 MB内存的函数在达到上限之前经历的冷启动次数明显更少</li><li>值得注意的是，与其他函数相比，1536 MB的函数也有一个较低的上限(48分钟)</li></ul><p id="5dd6">数据似乎清楚地支持假设2<em>——空闲超时不是一个常数。</em>我们没有办法找出这些冷启动背后的原因，或者45分钟障碍是否有意义。</p><h4 id="1404">结论</h4><p id="476a">AWS Lambda通常会在45-60分钟不活动后终止功能，尽管有时空闲功能可以提前终止，以释放其他客户所需的资源。</p><p id="c748">我希望你觉得这个实验很有趣——它只是为了好玩和满足好奇心——仅此而已！请不要在假设这些结果有效的基础上构建应用程序，或者假设它们在可预见的未来仍然有效。实验的<a href="https://github.com/theburningmonk/lambda-when-will-i-coldstart">源代码。</a></p><p id="1900">虽然我回答了几个问题，但这个实验的结果也值得进一步研究。例如，与其他函数相比，1536 MB函数表现出非常不同的行为。这是个特例，还是1024 MB以上内存的函数都有这些特质？</p><p id="b0e7">我很想知道。也许以后我会写一篇这个实验的后续。(用于命令)等待下面发表的消息😉</p><hr class="wp-block-separator is-style-wide"/><h2 class="has-text-align-center" id="h-get-the-skills-you-need-for-a-better-career">获得更好职业所需的技能。</h2><p class="has-text-align-center">掌握现代技术技能，获得认证，提升您的职业生涯。无论您是新手还是经验丰富的专业人士，您都可以通过实践来学习，并在ACG的帮助下推进您的云计算职业生涯。</p><hr class="wp-block-separator is-style-wide"/><p id="7532"><em>感谢阅读！如果你喜欢你所读的，点击下面的❤按钮，以便其他人可以找到它。可以</em> <a href="https://web.archive.org/web/20190503125920/https://twitter.com/theburningmonk" rel="noreferrer noopener" target="_blank"> <em>在Twitter上关注我</em> </a> <em>。</em></p></div></div>    
</body>
</html>