<html>
<head>
<title>How much code do I have? A DevSecOps story | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>我有多少代码？DevSecOps故事|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/how-much-code-do-i-have-a-devsecops-story#0001-01-01">https://acloudguru.com/blog/engineering/how-much-code-do-i-have-a-devsecops-story#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p class="has-text-align-left">by Darwin Sanoy <br/> <a href="https://missionimpossiblecode.io" target="_blank" rel="noreferrer noopener">博客</a> | <a href="https://twitter.com/DarwinTheorizes" target="_blank" rel="noreferrer noopener">推特</a>|<a href="https://www.linkedin.com/in/darwinsanoy" target="_blank" rel="noreferrer noopener">LinkedIn</a>|<a href="https://gitlab.com/DarwinJS" target="_blank" rel="noreferrer noopener">git lab</a></p><h3 id="h-the-age-of-devsecops-is-upon-us"><strong>开发警察的时代即将来临</strong></h3><p>作为GitLab解决方案架构师，我与许多客户一起考虑他们对DevSecOps的前瞻性计划。随着新的威胁和漏洞不断被发现，每个人都理所当然地关注代码安全性。不幸的是，计算中的坏人有一个非常敏捷的发布周期。</p><p>我看到所有类型的组织都在努力改进他们的DevSecOps游戏。由于DevSecOps完全是关于App Sec程序中可以自动化的部分，所以这种转变的很大一部分是评估什么工具选择是最相关和最划算的。</p><p>在许多情况下，这意味着将扫描工具的使用从早期采用者推进到所有代码都被扫描的程度。</p><p>我鼓励客户制定一个DevSecOps成熟度和TCO计划，该计划预测他们对成熟DevSecOps的总成本。出于多种原因，同时规划成熟度和总体拥有成本至关重要。令人惊讶的是，许多组织还没有计划好“成熟的DevSecOps”对他们来说意味着什么——他们已经抓了一些工具，并开始进行一些扫描。对DevSecOps的无计划的有机方法的总拥有成本可能导致非常不均衡和不断上升的成本，以及在知道整个操作何时对公司和手边的代码库来说是“成熟的”时缺乏远见。</p><h3 id="h-forecasting-security-scanning-costs-for-mature-devsecops"><strong>预测成熟开发团队的安全扫描成本</strong></h3><p>作为评估的一部分，许可的安全扫描工具有各种各样的许可模式。许多流行的扫描工具按扫描的代码量收费。</p><p>以下是一些流行的基于音量的模型:</p><ul><li>扫描的代码行</li><li>扫描的兆字节代码</li><li>扫描的应用程序数量</li></ul><p>有些可能根据对相同代码的每次扫描的累计来收费，有些可能根据“受管理的唯一代码行/MB”来收费，因此重复扫描相同代码不会产生成本。</p><p>组织可能需要预测这一成本的几个关键转折点:</p><ul><li>评估使用基于卷的工具提升开发成本的真实成本</li><li>考虑到代码库的增长，尝试为DevSecOps做预算</li><li>当比较各种扫描工具选择的总拥有成本时</li><li>在评估整合安全工具的真实成本或节约时</li><li>当考虑扫描处于“仅安全修复”状态的代码的频率时</li><li>当大型代码库被继承时——比如在公司收购期间</li></ul><p>请注意，上面的列表意味着对代码进行计数可能是一项持续的需求。</p><p>在所有这些情况下，一个核心挑战是获得扫描工具用来确定欠什么的代码库指标，而不必在所有存储库上配置他们的工具。</p><p>如果您参与了一个比较扫描工具的项目，那么拥有统计数据和在不产生设置每个正在考虑的工具的成本的情况下获得统计数据更为重要。</p><h3 id="h-how-hard-can-counting-be">数数能有多难？</h3><p>我们中的绝大多数人在记事之前就被教会了数数。那么，用一个快速脚本将几行或几兆字节的源代码加起来会有多难呢？</p><p>如果您的存储库中只有源代码(没有二进制文件和非代码文件),并且如果您只打算扫描代码的默认分支，这可能相当简单。</p><p>但是，如果您需要消除二进制文件或任何其他文件类型(例如，markdown)，这可能会变得很有挑战性。此外，如果您不打算扫描monorepo中的所有内容，这可能很难管理。</p><p>作为第一步，我们将使用Git命令来消除二进制文件和其他非代码文件。您可以使用扩展名排除列表来指明不是代码文件的文件。</p><p>之后，我们将看看如何使用专门计算代码行的实用程序，包括消除空白和注释。</p><p>无论您使用什么来计算代码，Git命令优化不仅将签出文件的范围扩大到代码文件，而且使扫描大型存储库和大量存储库的速度更快、成本更低。</p><h3 id="h-optimizing-counting-things-with-blue-through-exclusion"><strong>通过排除优化计数“带蓝色的东西”</strong></h3><p>想象你正从城市公寓搬到一个新家。你的家庭用品被装在一个集装箱里，随时可以运走。就在这时，你收到新居所在地政府的通知，通知你新居民必须为他们的一些物品缴税。这个地方有点奇怪，他们只是想让你在任何有蓝色的物品上每磅支付5便士。(不，美国新泽西州没有这个要求，但这是一个合理的猜测。)</p><p>对于称重过程，你需要将箱子搬回你的公寓，打开它们，找到蓝色的物品，称重，并跟踪总重量。</p><p>幸运的是，你已经能够从工作中借用一套高速机器人，你可以给他们关于选择和处理物品的具体指示。不幸的是，他们没有配备秤，所以你必须做称重和计数。</p><p>有两种方法可以让机器人优化你的任务:</p><ol><li>让他们把箱子带到公寓，只打开含有蓝色的东西，以便称重。</li><li>让他们在卡车上找到盒子里的蓝色东西，只把这些东西带到公寓。</li></ol><p>事实证明，我们有这两个选项和一些更新的Git功能。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/7bb0af10129e2f1b455fed6288ef43c8.png" alt="" class="wp-image-38989" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1024/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/08/DevSec_BlogInterior.jpg 1024w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/08/DevSec_BlogInterior.jpg 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/08/DevSec_BlogInterior.jpg 768w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1536/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/08/DevSec_BlogInterior.jpg 1536w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1700/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/08/DevSec_BlogInterior.jpg 1700w" sizes="(max-width: 1024px) 100vw, 1024px" data-original-src="https://acloudguru.com//app/uploads/2020/08/DevSec_BlogInterior-1024x373.jpg?x64535"/></figure><h3 id="h-two-times-we-take-a-size-and-time-hit"><strong>两次我们取一个尺寸，时间命中</strong></h3><p>我们将要讨论的优化可以节省磁盘空间和时间。如果您计划在许多存储库上运行它，那么这两者都会显著地影响这个过程。磁盘空间可能会溢出，或者需要对一次可以处理多少个存储库进行繁琐的管理，以避免溢出。如果你在一个付费的CI系统上运行，那么运行时间长度就等于实际花费。</p><p>在使用Git存储库时，有两种可能的情况，您可能会因为二进制内容或其他不需要的文件而受到大小和时间的影响:</p><ol><li>当从远程接收git历史数据(Git克隆或获取)时，默认情况下，传输所有存储库历史的所有分支的所有文件。</li><li>当将Git文件解包(git checkout)到工作目录中时，提取目标分支的所有文件。</li></ol><p>下面的一些Git优化命令关注的是根本不要从服务器复制数据，而其他一些命令关注的是不要提取假定存在于传输数据中的数据。</p><p>在下面的例子中，我们将假设这个克隆明确地用于计数的目的，并将在之后被丢弃。为了使它也能用于构建活动，需要额外的Git命令来将克隆重新配置为更可用的状态。</p><h3 id="h-having-git-do-the-heavy-lifting"><strong>让Git做繁重的工作</strong></h3><p>Git将在克隆期间选择要转移的历史，并选择要检出的内容。结果应该只是我们默认分支上的当前代码。这使得总大小估计或按文件扩展名的大小估计变得更加容易，因为我们只有想要计数的文件。</p><h3 id="h-optimization-test"><strong>优化测试</strong></h3><p>对于我们的示例代码，我们将使用存储库www-gitlab-com，因为它包含许多web图形文件形式的二进制文件和重要的Git历史，并且它是公开可用的。选择较大的文件可以更容易地根据文件大小判断命令是否正确执行。</p><p>以下是判断命令是否正确执行的方法:</p><figure class="wp-block-table is-style-stripes"><table><thead><tr><th>常规尺寸</th><th>优化尺寸</th><th>www-gitlab-com .git folder</th></tr></thead><tbody><tr><td>4.2 GB</td><td>111 MB</td><td>git克隆时间(无检验)</td></tr><tr><td>21分钟</td><td>46秒</td><td>www-gitlab-com文件(除。git文件夹)</td></tr><tr><td>2.7 GB </td><td>260 MB</td><td>git checkout time</td></tr><tr><td>27秒</td><td>19秒</td><td>检出的对象</td></tr><tr><td>15546</td><td>4467</td><td>计算代码行数</td></tr><tr><td>207925</td><td>206658*</td><td><strong>部分克隆到部分拯救</strong></td></tr></tbody></table><figcaption><em>*Note: sparse-checkout reduces the ruby file count and therefore the lines count. I was not able to discover why before the publishing due date.</em></figcaption></figure><h3 id="h-partial-clone-to-the-partial-rescue">每次从远程Git服务请求Git克隆时，Git服务都会准备一个包文件发送给客户机。部分克隆是许多公司和个人开发的一项新功能，它通过传递排除特定对象的指令来利用这一准备步骤。</h3><p>如果后续的本地Git命令需要，最初被部分克隆排除的对象将被自动从远程设备中取出。因此，如果您进行部分克隆以防止二进制文件出现，但随后签出包含二进制文件的分支，则该二进制文件将在签出过程中被删除。排除过滤器规范不会在所有后续的本地Git命令上强制实施。这是一种自动行为，旨在防止部分克隆中断当前工作流。</p><p>下面的部分克隆从中筛选出所有文件。git历史记录:</p><p>要使部分克隆工作，您必须安装Git 2.22或更高版本。</p><pre class="wp-block-preformatted">```bash
git clone --filter=blob:none --no-checkout https://gitlab.com/gitlab-com/www-gitlab-com.git
```</pre><p><strong>浅层克隆优化更多</strong></p><h3 id="h-shallow-clone-to-optimize-more">对于代码计数，我们不需要完整的git历史记录，因此我们可以在克隆或获取时使用–depth 1来减少。git文件夹甚至更多，用于我们将要下载的文本文件。为此，我们将在Git命令中添加“深度1 ”,如下所示:</h3><p><strong>稀稀拉拉的结帐去营救剩下的人</strong></p><pre class="wp-block-preformatted">```bash
git clone --depth 1 --filter=blob:none --no-checkout https://gitlab.com/gitlab-com/www-gitlab-com.git
```</pre><h3 id="h-sparse-checkout-to-the-rest-of-the-rescue">Git的稀疏签出特性是我们如何防止我们从历史中移除的不需要的文件在签出期间被动态地从原点拉出来。</h3><p>稀疏签出允许使用与相同配置的文件。gitignore，它会在执行checkout命令时过滤哪些内容将被检出，哪些内容不会被检出。</p><p>我们需要启用稀疏检出，然后用非代码文件的文件规范配置稀疏检出文件。您可能想要完善一个非代码/二进制文件的主列表，您可以在所有存储库中重用该列表作为稀疏签出文件。还有一个聪明的方法来存储这个文件。git并将其用于部分克隆和稀疏检验。对于该方法，请通读以下文档并扫描文件名。gitfilterspec": <a href="https://docs.gitlab.com/ee/topics/git/partial_clone.html#filter-by-file-path"> GitLab部分克隆</a>。</p><p>这段代码将我们设置好，然后检查master。</p><p>为了让稀疏校验正常工作，您必须至少拥有Git 2.25。</p><pre class="wp-block-preformatted">```bash
git sparse-checkout init
echo -e '*.* \n!**/*.idx \n!**/*.mp4 \n!**/*.gif \n!**/*.pdf \n!**/*.png \n!**/*.jpg \n!**/*.jpeg \n!**/*.eps \n!**/*.md \n' &gt; .git/info/sparse-checkout
git checkout master
```</pre><p><strong>计算代码行数</strong></p><h3 id="h-counting-lines-of-code">由于多种原因，计算代码行数具有挑战性，最值得注意的是代码中的注释不算一行。此外，有必要知道您使用什么语言，因为您的安全工具需要覆盖所有语言。</h3><p>出于文档的目的，这里有一些通用的shell代码，用于计算所有文件的行数。但是，如果您将它与下面的计数实用程序的输出进行比较，您会发现这种方法有很大的误差，并且很可能需要专门针对文件类型。</p><p>即使对于我们最基本的代码计数版本，使用专门的代码计数实用程序也是有意义的。</p><pre class="wp-block-preformatted">```bash
 find . -type f -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
```</pre><p>我对可用于这项任务的开源工具做了一个调查，最终选择了本·博伊特(Ben Boyte)r的“<a href="https://github.com/boyter/scc/" target="_blank" rel="noreferrer noopener">sloc cloc code</a>”——简称scc。它在现代编码语言(Go)中得到积极维护。如果您有自定义需求，它还允许您扩展语言支持。下面是处理测试存储库后的输出示例:</p><p>语言</p><figure class="wp-block-table is-style-stripes"><table><thead><tr><th>文件</th><th>线</th><th>空白</th><th>评论</th><th>密码</th><th>复杂性</th><th>Ruby HTML</th></tr></thead><tbody><tr><td>1179</td><td>119432</td><td>33420</td><td>948</td><td>85064</td><td>14177</td><td>挽救（saving的简写）</td></tr><tr><td>1077</td><td>18822</td><td>621</td><td>194</td><td>18007</td><td>3</td><td>低增生性急性髓细胞性白血病</td></tr><tr><td>782</td><td>39804</td><td>3648</td><td>204</td><td>35952</td><td>0</td><td>亚姆</td></tr><tr><td>723</td><td>116946</td><td>8626</td><td>2066</td><td>106254</td><td>0</td><td>厚颜无耻</td></tr><tr><td>324</td><td>52671</td><td>9090</td><td>3578</td><td>40003</td><td>88</td><td>红宝石</td></tr><tr><td>136</td><td>11068</td><td>2094</td><td>626</td><td>8345</td><td>486</td><td>Java Script语言</td></tr><tr><td>125</td><td>31952</td><td>3917</td><td>3739</td><td>24296</td><td>3437</td><td>超文本标记语言</td></tr><tr><td>12</td><td>1231</td><td>101</td><td>123</td><td>1007</td><td>0</td><td>视图(view)</td></tr><tr><td>11</td><td>1519</td><td>79</td><td>0</td><td>1440</td><td>89</td><td>纯文本</td></tr><tr><td>4</td><td>7</td><td>2</td><td>0</td><td>5</td><td>0</td><td>半铸钢ˌ钢性铸铁(Cast Semi-Steel)</td></tr><tr><td>3</td><td>926</td><td>155</td><td>四</td><td>767</td><td>0</td><td>壳</td></tr><tr><td>3</td><td>86</td><td>20</td><td>七</td><td>59</td><td>9</td><td>JSON</td></tr><tr><td>2</td><td>278</td><td>0</td><td>0</td><td>278</td><td>0</td><td>降价</td></tr><tr><td>2</td><td>65</td><td>15</td><td>0</td><td>50</td><td>0</td><td>战斗支援车</td></tr><tr><td>一</td><td>58</td><td>0</td><td>0</td><td>58</td><td>0</td><td>乳液</td></tr><tr><td>一</td><td>176</td><td>9</td><td>8</td><td>159</td><td>0</td><td>计算机编程语言</td></tr><tr><td>一</td><td>363</td><td>9</td><td>3</td><td>351</td><td>19</td><td>可扩展标记语言</td></tr><tr><td>一</td><td>12</td><td>0</td><td>0</td><td>12</td><td>0</td><td>吉蒂尔</td></tr><tr><td>1</td><td>36</td><td>9</td><td>5</td><td>22</td><td>0</td><td><strong>总计</strong></td></tr><tr><td><strong> 4388 </strong></td><td><strong> 395452 </strong></td><td><strong> 61815 </strong></td><td><strong> 11505 </strong></td><td><strong> 322132 </strong></td><td><strong> 18318 </strong></td><td>下面是获得上述输出的代码:</td></tr></tbody></table><figcaption>Estimated Cost to Develop $11,615,312<br/>Estimated Schedule Effort 38.958526 months<br/>Estimated People Required 35.316937<br/>Processed 41026462 bytes, 41.026 megabytes (SI)</figcaption></figure><p>scc有许多选项，您可以在开源项目中或者通过使用–<em>-help</em>命令行选项来检查。</p><pre class="wp-block-preformatted">```bash
go get -u github.com/boyter/scc/
scc .
```</pre><p><strong>计数码的MB数</strong></p><h3 id="h-counting-mbs-of-code">由于我们已经从文件层次结构中排除了所有非代码文件，我们可以通过以下代码大致了解MBs:</h3><p>上面的方法需要一个精确的排除标准，以确保除了代码文件之外什么都没有——这不是一个简单的任务，可能需要在每个存储库的基础上花费大量的精力。</p><pre class="wp-block-preformatted">```bash
cd www-gitlab-com
du -sh
```</pre><p>由于这个挑战，我向Ben Boyter的OSS项目提出了一个请求，看看scc是否可以更新到计算MBs，他能够将其工作到版本2.13.0！谢谢你，本！据我所知，你现在只有几行代码计数器可以做到这一点！</p><p>根据请求，Ben还花时间更新了scc，以便它可以在一次计数运行后输出多种格式——因此，如果它还不够快，现在我们不必调用它两次或更多次来获得我们想要的输出格式。如果你一次分析一大堆存储库，这将使一切保持超快的速度。</p><p>scc通过简单地将它处理的每个代码文件的文件字节相加来计算字节数，这与消除空格和注释的行计数略有不同。如果您查看上面的控制台输出捕获，您可以看到它给出了所有文件的摘要。在数据输出格式中——JSON、HTML和CSV——它将给出每种语言的字节数。我们下面的代码使用w3m将html文件转储到控制台，这样我们就可以获得控制台输出中的字节。</p><p><strong>对编译后的二进制文件进行字节计数</strong></p><h3 id="h-counting-bytes-of-compiled-binaries">一些漏洞工具会扫描编译好的二进制文件。下面的shell oneliner根据您提供的扩展名列表来计算文件大小。在示例中，*。jpg和*。png用于www-gitlab-com repo示例。删除扩展引用和括号会导致看到所有扩展的结果。在下面完成的脚本中，awk用于格式化CSV和HTML数据格式。Find有一个not运算符"！"可以在-iname参数前使用它来创建排除列表。</h3><p><strong>将所有这些整合在一起</strong></p><pre class="wp-block-preformatted">```bash
find . -type f \( -iname \*.jpg -o -iname \*.png \) |  egrep -o "\.[a-zA-Z0-9]+$" | sort -u | xargs -I '%' find . -type f -name "*%" -exec du -ch {} + -exec echo % \; | egrep "^\.[a-zA-Z0-9]+$|total$" | uniq | paste - -
```</pre><h3 id="h-bringing-it-all-together">下面的代码使用Docker，这样您就可以轻松地在本地进行测试，并将其移植到基于容器的CI系统。</h3><p>**注意:** scc非常快(在这项任务中比CLOC快3600%)，对于各种输出格式运行多次并不像看起来那么昂贵。</p><p><strong>最终输出</strong></p><div class="wp-container-640f29c3e752f wp-block-group"><div class="wp-block-group__inner-container"><pre class="wp-block-code"><code>```bash
docker run -it golang:1.15rc1-alpine3.12 sh #golang on a distro with a proper package manager
apk update; apk add git w3m #need at least 2.25 of git, w3m to render html in console
go get -u github.com/boyter/scc/
git clone --depth 1 --filter=blob:none --no-checkout https://gitlab.com/gitlab-com/www-gitlab-com.git
cd www-gitlab-com
git config --local core.sparsecheckout true
echo -e '*.* \n!**/*.idx \n!**/*.mp4 \n!**/*.gif \n!**/*.pdf \n!**/*.png \n!**/*.jpg \n!**/*.jpeg \n!**/*.eps \n!**/*.md \n' &gt; .git/info/sparse-checkout
git checkout master

#html for easy viewing as a CI artifact and json for data ingestion
time scc . --not-match .*md --format-multi "html:loc.html,json:loc.json"
w3m -dump loc.html

echo "Total Bytes of jpgs and pngs (emulating counting your binary code files) in csv:"
time find . -type f \( -iname \*.jpg -o -iname \*.png \) |  egrep -o "\.[a-zA-Z0-9]+$" | sort -u | xargs -I '%' find . -type f -name "*%" -exec du -c {} + -exec echo % \; | egrep "^\.[a-zA-Z0-9]+$|total$" | uniq | paste - - | awk 'BEGIN {print "Type,Bytes"}{print $1 "," $2*1024}' &gt; binarysize.csv

echo "Total Bytes of jpgs and pngs (emulating counting your binary code files) in HTML:"
time find . -type f \( -iname \*.jpg -o -iname \*.png \) |  egrep -o "\.[a-zA-Z0-9]+$" | sort -u | xargs -I '%' find . -type f -name "*%" -exec du -c {} + -exec echo % \; | egrep "^\.[a-zA-Z0-9]+$|total$" | uniq | paste - - | awk 'BEGIN {print "&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;binary bytes html output&lt;/title&gt;&lt;style&gt;table { border-collapse: collapse; }td, th { border: 1px solid #999; padding: 0.5rem; text-align: left;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=\"binarybytes-table\" border=1&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;"}{print "&lt;tr&gt;&lt;th&gt;" $1 "&lt;/th&gt;&lt;th&gt;" $2*1024 "&lt;/th&gt;&lt;/tr&gt;"}END { print "&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;" }' &gt; binarysize.html
w3m -dump binarysize.html
```</code></pre></div></div><h3 id="h-final-output">下面是上面输出的一个例子，包括代码的字节。</h3><p>语言</p><figure class="wp-block-table is-style-stripes"><table><thead><tr><th>文件</th><th>线</th><th>空白</th><th>评论</th><th>密码</th><th>复杂性</th><th>字节</th><th>挽救（saving的简写）</th></tr></thead><tbody><tr><td>1077</td><td>18822</td><td>621</td><td>194</td><td>18007</td><td>3</td><td>19395861</td><td>低增生性急性髓细胞性白血病</td></tr><tr><td>762</td><td>39700</td><td>3635</td><td>204</td><td>35861</td><td>0</td><td>2087355</td><td>亚姆</td></tr><tr><td>723</td><td>116857</td><td>8622</td><td>2057</td><td>106178</td><td>0</td><td>5572000</td><td>厚颜无耻</td></tr><tr><td>324</td><td>52666</td><td>9089</td><td>3578</td><td>39999</td><td>88</td><td>1057903</td><td>Ruby HTML</td></tr><tr><td>179</td><td>6643</td><td>593</td><td>0</td><td>6050</td><td>625</td><td>391692</td><td>红宝石</td></tr><tr><td>136</td><td>11095</td><td>2097</td><td>627</td><td>8371</td><td>484</td><td>333413</td><td>Java Script语言</td></tr><tr><td>125</td><td>31952</td><td>3917</td><td>3739</td><td>24296</td><td>3447</td><td>3423974</td><td>超文本标记语言</td></tr><tr><td>12</td><td>1228</td><td>100</td><td>123</td><td>1005</td><td>0</td><td>73922</td><td>某视频剪辑软件</td></tr><tr><td>11</td><td>1519</td><td>79</td><td>0</td><td>1440</td><td>89</td><td>45610</td><td>纯文本</td></tr><tr><td>四</td><td>七</td><td>2</td><td>0</td><td>5</td><td>0</td><td>327</td><td>半铸钢ˌ钢性铸铁(Cast Semi-Steel)</td></tr><tr><td>3</td><td>926</td><td>155</td><td>四</td><td>767</td><td>0</td><td>14658</td><td>壳</td></tr><tr><td>3</td><td>86</td><td>20</td><td>七</td><td>59</td><td>9</td><td>2174</td><td>JSON</td></tr><tr><td>2</td><td>278</td><td>0</td><td>0</td><td>278</td><td>0</td><td>7117</td><td>降价</td></tr><tr><td>2</td><td>65</td><td>15</td><td>0</td><td>50</td><td>0</td><td>4170</td><td>战斗支援车</td></tr><tr><td>一</td><td>58</td><td>0</td><td>0</td><td>58</td><td>0</td><td>15278</td><td>乳液</td></tr><tr><td>一</td><td>176</td><td>9</td><td>8</td><td>159</td><td>0</td><td>4309</td><td>计算机编程语言</td></tr><tr><td>一</td><td>363</td><td>9</td><td>3</td><td>351</td><td>19</td><td>13394</td><td>可扩展标记语言</td></tr><tr><td>一</td><td>12</td><td>0</td><td>0</td><td>12</td><td>0</td><td>391</td><td>吉蒂尔</td></tr><tr><td>1</td><td>36</td><td>9</td><td>5</td><td>22</td><td>0</td><td>538</td><td><strong>总计</strong></td></tr><tr><td><strong> 3368 </strong></td><td><strong> 282489 </strong></td><td><strong> 28972 </strong></td><td><strong> 10549 </strong></td><td><strong> 242968 </strong></td><td><strong> 4764 </strong></td><td><strong> 32444086 </strong></td><td><strong>交叉校验结果</strong></td></tr></tbody></table></figure><h3 id="h-cross-checking-results">由于scc对较老但古老的CLOC有类似的语言支持，您可以像这样交叉检查较老的实用程序(假设您在上面的Golang容器上):</h3><p>注意:虽然CLOC在计算代码方面做了一些改进，但在我对www-gitlab-com的测试中，花费的时间是它的24到36倍，结果也非常相似。</p><pre class="wp-block-preformatted">```bash
apk add cloc
time cloc .
```</pre><p><strong> MissionImpossibleCode.io现场编码改进此代码</strong></p><h3 id="h-missionimpossiblecode-io-live-coding-to-improve-this-code">在<a href="https://missionimpossiblecode.io/post/mission-impossible-live-coding/">碟中谍现场编码</a>的前一集中，我和我的同事Jefferson Jones能够让scc作为一个可重用的GitLab CI CD插件运行。在未来的一期中，我们将会让这变得更加灵活——通过允许一个存储库列表(而不是一次做一个)和一些代码在GitLab组层次结构中遍历所有项目。你可以在这里了解更多关于碟中谍现场编码事件<a href="https://missionimpossiblecode.io/post/mission-impossible-live-coding/">。</a></h3><p><strong>最后一个“蓝色的东西”优化</strong></p><h3 id="h-one-final-things-with-blue-optimization">让我们回到你的公寓——那个有蓝色分类机器人的公寓。当你正在考虑如何完成计数任务时，其中一个机器人突然灵机一动(它可能有一些吸尘器的DNA)，并暗示公寓垃圾桶比你的公寓更靠近包装容器。因此，简单地扔掉所有“蓝色的东西”将会节省大量的时间、精力和税款。移情和怀旧算法，有人知道吗？</h3><p><strong>用GitLab做数字</strong></p><h3 id="h-doing-the-numbers-with-gitlab">了解工具和流程的总成本是当前状态和未来发展的关键。GitLab有一些工具可以帮助这个部门。<a rel="noreferrer noopener" href="https://about.gitlab.com/stages-devops-lifecycle/secure/" target="_blank"> GitLab Secure </a>与第三方扫描器集成，可以直接向开发人员报告漏洞，这些开发人员在他们的下一个功能分支构建时会立即引入这些漏洞(将<strong>向左硬移</strong>)。如果GitLab附带的免费扫描仪足以满足您的扫描需求，那么它们没有任何基于使用的定价。因此，当一些工具整合成为可能时，您可能会节省一些钱。点击此处，了解更多关于GitLab Secure <a rel="noreferrer noopener" href="https://about.gitlab.com/stages-devops-lifecycle/secure/" target="_blank">的详情。</a></h3><p>Understanding the total cost of tooling and processes is key for the current state and future growth. GitLab has some tools that can help in this department. <a rel="noreferrer noopener" href="https://about.gitlab.com/stages-devops-lifecycle/secure/" target="_blank">GitLab Secure</a> integrates with third-party scanners and can report vulnerabilities directly to the developers who introduced them immediately upon their next feature branch build (shifting <strong>hard left</strong>). If the free scanners that come with GitLab are sufficient for your scanning needs, they don’t have any usage-based pricing. So when some tool consolidation is possible, you can potentially save some money. Find more details on GitLab Secure <a rel="noreferrer noopener" href="https://about.gitlab.com/stages-devops-lifecycle/secure/" target="_blank">here</a>.</p></div></div>    
</body>
</html>