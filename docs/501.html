<html>
<head>
<title>I’m here to tell you the truth, the good, the bad and the ugly of AWS X-Ray and Lambda | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>我在这里告诉你真相，好的，坏的和丑陋的AWS X射线和λ|一个云大师</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/im-here-to-tell-you-the-truth-the-good-the-bad-and-the-ugly-of-aws-x-ray-and-lambda#0001-01-01">https://acloudguru.com/blog/engineering/im-here-to-tell-you-the-truth-the-good-the-bad-and-the-ugly-of-aws-x-ray-and-lambda#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p id="abf3">AWS <a href="https://aws.amazon.com/blogs/aws/aws-lambda-support-for-aws-x-ray/" target="_blank" rel="noreferrer noopener">早在5月份就宣布了对AWS X-Ray的AWS Lambda支持的全面可用性——我花了一些时间来尝试它。虽然我看到了大量的价值，但它目前的局限性极大地限制了它在复杂系统中的有用性。</a></p><p id="a80d">特定于AWS Lambda的文档有点支离破碎，所以我依赖一些实验，并从几个来源拼凑线索:</p><p id="b556">我发现记录注释和元数据并不像在<a href="http://docs.aws.amazon.com/xray/latest/devguide/scorekeep-lambda.html" target="_blank" rel="noreferrer noopener">样本</a>中宣传的那样工作——尽管我可能做错了什么。</p><p><strong>2017年07月03日更新:</strong> <em>这篇文章发表后，AWS的人取得了联系，并友好地澄清了这里强调的一些问题，这些问题是由糟糕的文档引起的，他们将在不久的将来纠正这些问题。向下滚动以查看相关部分的说明。</em></p><h3 id="h-the-sample-application">示例应用程序</h3><p id="444a">我创建的示例项目以一个名为<code>service-a</code>的Lambda函数为中心，这个函数调用了许多下游系统:</p><ul><li>发布到SNS主题</li><li>在S3得到和放置一个物体</li><li>获取并在DynamoDB中放置一行</li><li>使用Lambda API调用另一个Lambda函数(<code>service-c</code>)</li><li>向由另一个Lambda函数支持的API网关端点发出HTTP请求——图中的<code>service-b</code>、<code>error</code>和<code>timeout</code>函数分别表示成功、错误和超时的情况</li></ul>  <h3 id="2a52">好人</h3><p id="191f">一旦我破解了魔法咒语，我就能得到结果。这花费了更多的时间和精力——但总的来说，大多数功能在第一次(或第二次)询问时就像宣传的那样工作了。</p><p id="f82a">下面是对<code>service-a</code>函数的跟踪，包括Lambda初始化该函数所花费的时间，以及它与之对话的各种下游系统——所有这些都嵌套在自定义子段下。</p><p id="3cbc">它甚至包括使用Lambda API调用的<code>service-c</code>函数的踪迹——以及它发布到SNS所花费的时间。</p><p><code>service-a</code>的服务地图包括作为下游依赖的<code>service-c</code>，以及<code>service-c</code>对SNS的依赖。</p><h3 id="c197">坏消息是——它总是一个200的响应代码</h3><p id="bd05">当通过API网关端点和错误调用<code>service-a</code>函数时，相应的跟踪仍然报告200响应代码。</p><p id="db26">大概X射线看到的是一个<code>200 response from the Lambda service whose payload indicates a 502 response to the API Gateway invocation</code>，所以它认为“嘿，这是一个200！”。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/1357b43168b2e9616bf1652f2af86b46.png" alt="Showing the service-a endpoint erred with 502 response to the API Gateway invocation." class="wp-image-42106" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_7V7FXCa3xl5-BKsGU9FgOA.png"/><figcaption>The service-a endpoint errored with 502</figcaption></figure></div><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/21514abc3a17eae2b3cd58cda6b1035b.png" alt="The trace timeline reported a 200 response code because the AWS Lambda service itself reported a 200." class="wp-image-42127" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_xR56ovfQuSO8-rVpM87F4g.png"/><figcaption>But the trace reported a 200 response code because (presumably) the AWS Lambda service itself reported a 200</figcaption></figure></div><p>奇怪的是，<code>error</code>函数的跟踪也报告200，尽管它自己的状态字段表明它出错了。</p><p id="3318">这种行为对我来说既困惑又矛盾——也许我误解了它是如何工作的。可悲的是，x光片的<a href="http://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html" target="_blank" rel="noreferrer noopener">概念</a>页面也没有解释<code>Error</code>和<code>Fault.</code>之间的区别</p><p id="de5c">虽然这现在看起来有点麻烦，但是当您需要诊断生产中的问题时，无法快速识别错误跟踪将对您造成最大的伤害。最有可能的是，当你时间压力最大的时候。</p><hr class="wp-block-separator is-style-dots"/><p><strong>更新2017年7月03日:</strong>T3】AWS确认错误被报告为200的原因是由于Lambda服务返回了200响应(带有指示错误的有效载荷)。一种解决方法是使用过滤表达式 <code>service() { fault }</code> <em>，它返回包含故障的所有轨迹。</em></p><hr class="wp-block-separator is-style-dots"/><h3 id="a668">跟踪不会跨越API网关</h3><p id="6674">当<code>service-a</code>函数向API网关端点发出HTTP请求时，跟踪会在API网关端点处停止，并且不会扩展到由API网关触发的Lambda函数。</p><p id="4273">这种行为与我测试的所有3个端点一致— <code> service-b</code>、<code>error</code>和<code>timeout</code>。</p><p>对于这个测试，在发出HTTP请求时，我遵循了X-Ray <a href="http://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-httpclients.html" target="_blank" rel="noreferrer noopener">文档</a>并使用X-Ray SDK来包装Nodejs <code>https</code>模块。</p>  <p>我可以看到跟踪id在传出的HTTP请求中被正确传递，并被处理Lambda函数接收。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/71060a2d4e97eda111a3e8745fbe31e8.png" alt="Trace IDs are passed along the HTTP headers in the GET request to the timeout function invocation." class="wp-image-42115" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_ExDk68H2mZ5e2sJygcMTnw.png"/><figcaption>Trace IDs are passed along the HTTP headers in the GET request to the timeout function invocation.</figcaption></figure></div><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/e1b8c91d3720385ef1e35ecab5fac19e.png" alt="The root trace ID correctly match the segment ID of the originating function’s trace." class="wp-image-42126" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_wMPHOjbPl9Ok5Jfs7oVEhw.png"/><figcaption>The root trace ID correctly match the segment ID of the originating function’s trace.</figcaption></figure></div><p>这是我期望在这种情况下看到的服务地图——其中<code>service-a</code>的跟踪通过HTTP请求到达ap I网关，并包括对<code>timeout</code>函数的调用。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/9b184d6df4e86d10041b4e3757c98e5f.png" alt="This is a composed image of what I would like to see — where traces follow through to Lambda invocations behind the failing HTTP request." class="wp-image-42125" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_W6eAIRTZm4TEzOYPwiLacA.png"/><figcaption>WARNING: this is not a screenshot! This is a composed image of what I would like to see — where traces follow through to Lambda invocations behind the failing HTTP request</figcaption></figure></div><p>相反，实际的服务映射在API网关处停止。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/3f4b2a25f91195bef5f253714b6db089.png" alt="Service graph showing the trace does not follow through to the Lambda function behind the outgoing HTTP request." class="wp-image-42121" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_NF4FRc_eTlS8V2kSJCi3Hw.png"/><figcaption>The trace does not follow through to the Lambda function behind the outgoing HTTP request</figcaption></figure></div><p id="7a85">然而，当直接调用另一个Lambda函数时(使用Lambda API和<a href="http://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-awssdkclients.html" target="_blank" rel="noreferrer noopener">包装的</a> AWS SDK ),跟踪按预期工作。</p><p id="1fb6">也许限制在于API网关？</p><p id="f870">下面您可以看到直接调用<code>service-c</code>所花费的时间，但是对<code>service-b</code>的跟踪停止在API网关层。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/29bfae35ac8d76a316c46491bc98e656.png" alt="The breakdown of time spent in service-c when it’s invoked directly, but the tracing to service-b stopped at the API Gateway layer." class="wp-image-42123" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_Px1LU9u_xY56C5IfxsU4ZA.png"/></figure><h3 id="78a6"><strong>丑陋的-n</strong>o采样</h3><p id="d9de">根据Lambda关于X射线的<a href="http://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html" target="_blank" rel="noreferrer noopener">文档</a>，请求应该以每分钟1个请求的速度进行采样。</p><figure class="wp-block-image"><img loading="lazy" src="../Images/c82503672bb559d15390f833400a2bee.png" alt="There are two modes of tracing for Lambda function, pass through and active. " data-original-src="https://miro.medium.com/max/1558/1*uD3m5NcNAK3lGMFPknC9xg.png"/></figure><p id="aee9">然而，在我的实验中情况并非如此。<strong>每个请求都被采样</strong>，从下面截图中的<code>age</code>痕迹可以看出。当通过API网关和Lambda管理控制台调用Lambda时，这种行为是一致的。</p><p id="bb49">虽然X射线服务本身并不昂贵(每百万次追踪5美元)，但如果你不愿意通过系统追踪每一个请求，这仍然是一笔很容易就会出现在你身上的费用。</p><p id="7168">例如，我在Gamesys用大约100万DAU开发了一款相当成功的社交游戏。按照每天大约2 . 5亿次用户请求计算，X-Ray的成本为5 * 250 * 30天= 37500美元，超过了我们当时的整个AWS账单！</p><p><strong>2017年07月03日更新:</strong> <em>这原来是文档的问题，它没有提到采样是基于量的，只有当你达到一定量的请求时才开始。</em></p><hr class="wp-block-separator is-style-wide"/><p class="has-text-align-center">想要深入了解AWS X-Ray等AWS开发工具吗？看看这些云专家课程！</p><hr class="wp-block-separator is-style-wide"/><h3 id="5919">注释和元数据仅适用于子段</h3><p id="0bd9">有一件事就是拒绝工作——尽管我已经遵循了<a href="http://docs.aws.amazon.com/xray/latest/devguide/scorekeep-lambda.html" target="_blank" rel="noreferrer noopener">示例</a>——向根段添加注释和元数据:</p><pre class="wp-block-code"><code>module.exports.handler = (event, context, callback) =&gt; {
  ...
  let segment = AWSXRay.getSegment();
  let n = Math.random() * 3;
  segment.addMetadata('random', `${n}`);      // this doesn't work
  segment.addAnnotation('path', event.path);  // this doesn't work
  ...
}</code></pre><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/78d912e5e0de4554c6d20591f9d266da.png" alt="Annotations subsegment for Lambda X-Ray." class="wp-image-42104" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/0_hz0ol4NKLpBUQX_n.png"/></figure><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/9f1663e0af463fbc212086175bd1c7e3.png" alt="Metadata subsegment Lambda X-Ray." class="wp-image-42112" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_ENarlBLXuARR9NQ-HbZn7g.png"/></figure><p>有趣的是，给子段添加注释和元数据效果很好。</p><pre class="wp-block-code"><code>let publishSNS = segment =&gt; {
  return new Promise((resolve, reject) =&gt; {
    console.log('publishing to SNS topic');
    
    let f = co.wrap(function* (subsegment) {
      ...
      subsegment.addAnnotation('topic', topicArn);
      subsegment.addMetadata('message', 'test');
      let req = {
        Message: message,
        TopicArn: topicArn
      };
      yield sns.publishAsync(req);
      subsegment.close();
      resolve();
    });
    
    AWSXRay.captureAsyncFunc("## publishing to SNS", f, segment);
  });
};</code></pre><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/cc6f1788ff7cfd84515cefc7ee478790.png" alt="Annotations subsegment publishing to SNS." class="wp-image-42109" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_a5ubC2jSidyuHppj_cOR6A.png"/></figure><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/6ae1e4a9426607d06b9f14bad7bd4db5.png" alt="Metadata subsegment publishing to SNS." class="wp-image-42113" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_EUGBlvdYBkYUS7UyaakBOQ.png"/></figure><p id="ffab">查看日志，我发现了一些有趣的事情:根段的段ID与X射线跟踪中的段ID不匹配。</p><p id="c422">例如，我在处理程序中获取我的函数的根段，并将其记录到CloudWatch日志中。</p><pre class="wp-block-code"><code>const AWSXRay = require('aws-xray-sdk');
module.exports.handler = (event, context, callback) =&gt; {
  ...
  // this should be the root segment for my function
  let segment = AWSXRay.getSegment();
  console.log(JSON.stringify(segment));
  ...
}</code></pre><p>在日志中，我可以看到段ID是<em> 05b2b9ac6c9e5682 </em>。</p><p>但是在X射线跟踪中，根段的段ID是<em>2 b 7 D5 B4 a2 d 96 e 9</em>。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/ad301f44c6dede878ca9d6849fd22ff3.png" alt="The segment ID of the root segment doesn’t match the one the function fetched at runtime." class="wp-image-42110" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_b1gH2NSJRSO2GPVE1CyX_Q.png"/><figcaption>The segment ID of the root segment doesn’t match the one the function fetched at runtime.</figcaption></figure></div><p id="7fd7">此外，跟踪ID也不同:</p><ul><li>在日志中是<em>1–59504311-d 765 e 7 accb 8558871 fa 89 d6d</em></li><li>在X射线控制台中是<em>1–59504312–5e F2 a3 EDA 0 C1 B2 C4 d 64 DD a00</em></li></ul><p id="6662">这很奇怪，所以我决定在X射线控制台的日志中跟踪跟踪ID，从冷启动开始。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/dad947fd530dd0c57cd330640482a43d.png" alt="The data showing  AWSXray.getSegment() returns the root segment from the previous invocation." class="wp-image-42122" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/1_OcMao2CZE4CZiuh6rUOsgg.png"/><figcaption>From the data it’s clear to see that AWSXray.getSegment() returns the root segment from the previous invocation</figcaption></figure></div><p>答对了。看起来这是Nodejs的X-Ray SDK中的一个错误，其中<code>AWSXray.getSegment()</code>从之前的调用中返回根段。</p><p><strong>2017年07月03日更新:</strong> <em>虽然X-Ray SDK wrt在跟踪trace-id时有一个bug，但根本不支持向根段添加注释和元数据，文档中没有明确说明。您可以通过创建一个覆盖整个函数调用的子段来解决这个问题，作为您的自定义根段，并在那里附加任何与调用相关的注释和元数据</em>。</p><h3 id="21a1">真相</h3><p id="4dc3">所以你有它，我的周末与AWS X射线和λ的恶作剧🙂</p><blockquote class="wp-block-quote"><p>“我来<strong>这里告诉你真相</strong>，<strong>好的、坏的和丑陋的</strong>。”—奥利弗·诺斯</p></blockquote><p id="98d3">总的来说，我对我所看到的印象深刻，并认为X射线会给我在Yubl 建造的<a href="https://medium.com/@theburningmonk/yubls-road-to-serverless-part-1-overview-ca348370acde" target="_blank" rel="noreferrer noopener">无服务器架构增加很多价值。然而，无法跨越API网关端点的跟踪使得它对我们的生态系统来说用处不大。</a></p><p id="48ad">此外，X射线服务侧重于执行时间，并帮助您识别性能瓶颈。然而，分布式跟踪还有一个X射线不关心的重要方面——通过确保在所有日志消息中捕获一组相关id来帮助您调试系统。</p><p id="7d88">虽然您可能可以使用X-Ray提供的跟踪id，但是您仍然有责任在所有日志消息中捕获它们，并将您的所有日志传播到一个易于搜索的位置。我们在Yubl的无服务器架构中投入了一些精力来实现分布式跟踪，你可以在这个<a href="https://hackernoon.com/yubls-road-to-serverless-part-3-ops-6c82139bb7ee" target="_blank" rel="noreferrer noopener">帖子</a>中读到详细信息。</p><p id="1726">您在生产中使用X射线吗？我很乐意听到你对这项服务的想法和反馈，以及在评论区寻找任何陷阱！</p><hr class="wp-block-separator is-style-wide"/><h2 class="has-text-align-center" id="h-get-the-skills-you-need-for-a-better-career">获得更好职业所需的技能。</h2><p class="has-text-align-center">掌握现代技术技能，获得认证，提升您的职业生涯。无论您是新手还是经验丰富的专业人士，您都可以通过实践来学习，并在ACG的帮助下推进您的云计算职业生涯。</p><hr class="wp-block-separator is-style-wide"/><p id="b8b3"><em>感谢阅读！如果你喜欢你所读的，点击下面的❤按钮，以便其他人可以找到它。可以</em> <a href="https://twitter.com/theburningmonk" target="_blank" rel="noreferrer noopener"> <em>在Twitter上关注我</em> </a> <em>。</em></p></div></div>    
</body>
</html>