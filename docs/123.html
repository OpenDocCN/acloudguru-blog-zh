<html>
<head>
<title>Serverless Scheduler (SNS) | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>无服务器调度程序(SNS) |云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/serverless-scheduler#0001-01-01">https://acloudguru.com/blog/engineering/serverless-scheduler#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p id="h-this-project-allows-developers-to-quickly-schedule-events-with-precision-allows-a-large-number-of-open-tasks-and-scales">该项目允许开发人员快速精确地安排事件，允许大量开放任务，并可扩展</p><h2 id="h-amazon-simple-notification-service-sns">亚马逊简单通知服务(SNS)</h2><p>AWS提供了许多优秀的服务，但在临时调度方面仍有潜力。我们使用术语临时调度来表示不规则的时间点调用，例如32小时一次，4天一次。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/f1e934e49c8ed2d14b63e1efd7760845.png" alt="Comparison of regular and irregular invocations (hoc scheduling)" class="wp-image-42295" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_9dwvWJotSP9SEPp5TE-Lzw.png"/><figcaption>Comparison of regular and irregular invocations</figcaption></figure></div><p id="91cd">扎克·查尔斯向<a href="https://medium.com/@zaccharles/there-is-more-than-one-way-to-schedule-a-task-398b4cdc2a75" target="_blank" rel="noreferrer noopener">展示了几种实现无服务器调度的方法</a>，每种方法在成本、准确性或未来时间方面都有各自的缺点。</p><p id="a8fb">在<a href="https://medium.com/u/d00f1e6b06a2?source=post_page-----23dec8edde06--------------------------------" target="_blank" rel="noreferrer noopener">崔琰</a>的<a href="https://theburningmonk.com/2019/06/step-functions-as-an-ad-hoc-scheduling-mechanism/" target="_blank" rel="noreferrer noopener">对step函数作为一种特别调度机制的分析</a>中，他列出了三个主要标准:</p><ol><li><strong>精度</strong>:任务的执行离我的预定时间有多近？越近越好。</li><li><strong>扩展—开放任务的数量</strong>:解决方案是否可以扩展以支持许多开放任务。即已调度但尚未执行的任务。</li><li><strong>扩展—热点:</strong>该解决方案能否扩展到在大约同一时间执行许多任务？例如，数百万人设置了一个计时器来提醒自己观看超级碗，所以所有的计时器都在接近开球时间时启动。</li></ol><p id="b47e">本文展示了我的<a href="https://github.com/bahrmichael/aws-scheduler" target="_blank" rel="noreferrer noopener">无服务器调度器</a>以及它如何根据这些标准执行。后续文章将进一步研究伸缩性和成本。</p><h2 id="c727"><strong>概述</strong></h2><p id="3ee9">该服务的两个输入接口是SNS输入主题和输出主题，前者接收要安排的事件，后者由消费帐户托管。</p><p id="d8b3">每个输入事件都必须包含一个SNS输出主题的ARN，一旦预定时间到来，有效负载将发布到该主题。</p><div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" src="../Images/6eff238982ed93eeae9dab65ceb58f45.png" alt=" SNS output topic: architecture of the scheduling service" class="wp-image-42299" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_Oo2ZdWCZAcmZb4-50mUjyg.png"/><figcaption>Architecture of the scheduling service</figcaption></figure></div><p id="42bd">在内部，该服务使用DynamoDB表来存储长期事件。预定时间少于10分钟的事件被直接放入短期队列。</p><p id="f467">此队列使用DelaySeconds属性让消息在适当的时间变得可见。事件加载器功能基本上是一个cron作业。发射器函数最终将事件发布到所需的主题。</p><h2 id="800d"><strong>用途</strong></h2><p id="723b">调度服务接受一个事件，该事件带有一个字符串负载、一个目标主题、预定的执行时间和一个用户代理。后者主要是识别来电者。</p><p id="76b4">上面的python代码发布了一个带有自定义字符串负载的事件。请确保您填写了所有四个字段，否则该活动可能会被取消。更多信息请参见本文末尾的<em>故障排除</em>部分。</p><p id="1680">请注意，我们必须创建自己的SNS主题，该主题必须向无服务器调度程序授予发布权限。<a href="https://github.com/bahrmichael/aws-scheduler-testing#prerequisites" target="_blank" rel="noreferrer noopener"> quickstart项目包含一个脚本</a>，帮助您创建SNS主题。公共无服务器调度器的AWS角色是<em>arn:AWS:STS::256608350746:assumed-role/AWS-scheduler-prod-us-east-1-λrole/AWS-scheduler-prod-emitter</em></p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/c6939846e4733540dc32b4c00046bfc1.png" alt="The AWS role of the public serverless scheduler" class="wp-image-42298" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_M6PasIttSQOiruyRF-t_5g.png"/></figure><p>您也可以手动为您的SNS主题分配额外的访问策略。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/0f2015bed11618288cc0e739ab4442b7.png" alt="Assigning additional access policy to a SNS topic" class="wp-image-42302" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_Wczc_h0mkjaK-gpucLhPHw.png"/></figure><p>之后，您需要一个<a href="https://docs.aws.amazon.com/en_pv/lambda/latest/dg/with-sns-example.html" target="_blank" rel="noreferrer noopener"> lambda函数，它从您的输出主题中消费</a>事件。</p><p id="8fb0">就是这样。您可以使用<a href="https://github.com/bahrmichael/aws-scheduler-testing#prerequisites" target="_blank" rel="noreferrer noopener">快速启动项目</a>快速安排和接收您的第一个活动。去试试吧！</p><h2 id="6492"><strong>评估</strong></h2><p id="e1b2">让我们回到引言中提到的标准:精度、规模和热点。</p><h2 id="h-precision">精确度</h2><p id="h-precision-is-probably-the-most-important-of-all-not-many-use-cases-are-tolerant-to-events-arriving-minutes-to-hours-late-a-sub-second-delay-however-is-viable-for-most-use-cases">精确可能是最重要的。没有多少用例能够容忍事件迟到几分钟到几小时。然而，亚秒级的延迟对于大多数用例来说是可行的。</p><p id="ace1">在过去的五天里，我每小时创建大约1000个事件的基本负载。发射器函数记录目标时间戳和当前时间戳，然后将它们进行比较以计算延迟。绘制这些数据给了我们下图。</p><p>如您所见，绝大多数低于100 ms，最大值接近1000 ms。当您查看直方图时，这一点变得更加清晰。</p><h2 id="h-scale"><strong>刻度</strong></h2><p>在这里，对许多开放任务进行缩放是很容易的。SQS和DynamoDB并没有硬性限制你可以处理多少个项目。因此，无服务器调度程序可以在存储器中保存数百万和数十亿个事件以供以后处理。</p>  <p id="5c17">根据与Daniel Vassallo的讨论，我不认为SQS会成为瓶颈。</p><p id="2ec2">唯一的瓶颈是事件加载器函数。不过，它使用了一个专用索引，有助于确定哪些项目将很快被安排。然后，它只加载数据库id，并将它们交给一个可伸缩的lambda函数，然后该函数将整个事件加载到短期队列中。</p><p id="0969">不同负载下的测试表明，瓶颈lambda函数每分钟能够处理超过100，000个事件，每月能够处理43亿个事件。由于成本增加，我没有进行更大规模的测试。欢迎投稿😉</p><h2 id="73c1"><strong>热点</strong></h2><p id="73c1">当大量事件到达输入主题或者要在很短的时间内发出时，热点就会出现。</p><p id="5028">DynamoDB被配置为使用按请求付费，这应该允许几乎无限的吞吐量峰值，但是当DynamoDB进行内部自动伸缩时，我必须添加一个重试机制。时间最关键的函数是<em>发射器</em>，它在向输出主题发出事件后执行任何可能的数据库操作。</p><p id="626a">SNS输入话题和SQS短期队列预计不会在高压下变慢，但消费lambdas可能会。</p>  <p id="b5c8"><a href="https://medium.com/u/c8eb1c0e04da?source=post_page-----23dec8edde06--------------------------------" target="_blank" rel="noreferrer noopener"> Randall Hunt </a>写了一篇<a href="https://aws.amazon.com/blogs/aws/aws-lambda-adds-amazon-simple-queue-service-to-supported-event-sources/#additional-info-lambda-sqs" target="_blank" rel="noreferrer noopener"> AWS博客文章</a>，深入探讨了这种情况下的并发和自动扩展。</p><blockquote class="wp-block-quote"><p>[…]Lambda服务将使用五个并行的长轮询连接开始轮询SQS队列。Lambda服务监控正在进行的消息的数量，当它检测到该数量呈上升趋势时，它会将轮询频率增加每分钟20个ReceiveMessage请求，并将函数并发性增加每分钟60个调用。</p></blockquote><p id="05a3">虽然lambda函数的冷启动会导致延迟略微增加，但轮询行为或最终的lambda并发限制会导致重大延迟。</p><p id="d6d3">为了测试这一点，我计划在几秒钟内发布30，000个事件。虽然中位数上升了很多(可能是由于冷启动)，但这仍然不足以达到任何限制。</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/1457ba89376feab4d56825e352eb7c28.png" alt="Scheduled test showing 30.000 events to be published within a couple seconds" class="wp-image-42303" data-original-src="https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2021/01/1_wjp2kYu-XTQrVVuNJ-ZIeA.png"/></figure><p id="2c37">总结热点部分:负载非常高的非常尖锐的尖峰可能会成为一个问题，但这些尖峰太大了，我还无法测试它们。</p><p id="6ce5">我对re:Invent 2019即将到来的一场深入SQS的演讲很感兴趣。</p>  <h2 id="h-troubleshooting-and-error-handling"><strong>故障排除和错误处理</strong></h2><p id="fbff">由于服务的异步特性，错误处理有点棘手。我决定不使用API网关端点来发布事件，因为它的成本为每百万事件3.5美元(相比之下，SNS的成本为每百万事件0.5美元)。错误可以发布到另一个输出主题，即失败主题。</p><p id="eb1c">如果事件没有在您的输出主题中发布，请首先确保您将正确的事件推送到输入主题。它必须包含所有四个字段<em>有效载荷</em>、<em>日期</em>、<em>目标</em>和<em>用户</em>。所有这些都必须是字符串。</p><p id="2cd5">您还可以在事件中添加一个字段<em> failure_topic </em>,其中包含您希望收到错误通知的另一个SNS主题的ARN。请注意，这必须与您的输出主题具有相同的无服务器调度程序发布权限。</p><h2 id="2fb7"><strong>结论</strong></h2><p id="1fb2">无服务器调度程序在精度和规模上都表现出色。热点可能会成为一个非常尖锐的峰值和异常的量的问题，但实际的限制仍有待发现。</p><p id="3ff1">我很高兴看到你的测试结果和你对无服务器调度程序的看法。去尝试一下<a href="https://github.com/bahrmichael/aws-scheduler-testing#prerequisites" target="_blank" rel="noreferrer noopener">快速启动项目</a>或者查看一下<a href="https://github.com/bahrmichael/aws-scheduler" target="_blank" rel="noreferrer noopener">源代码</a>。您会将它附加到您自己的项目中吗？</p><p id="8669">更多的测试和见解将在接下来的几周内公布。</p><hr class="wp-block-separator is-style-wide"/><h2 class="has-text-align-center" id="h-get-the-skills-you-need-for-a-better-career">获得更好职业所需的技能。</h2><p class="has-text-align-center">掌握现代技术技能，获得认证，提升您的职业生涯。无论您是新手还是经验丰富的专业人士，您都可以通过实践来学习，并在ACG的帮助下推进您的云计算职业生涯。</p><hr class="wp-block-separator is-style-wide"/><h4 id="h-want-some-more-serveless-goodness-check-these-out">想要更多无用的好处吗？看看这些:</h4></div></div>    
</body>
</html>