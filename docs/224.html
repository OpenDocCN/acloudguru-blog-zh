<html>
<head>
<title>Running Prometheus on Kubernetes | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Kubernetes |云专家上运行普罗米修斯</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/running-prometheus-on-kubernetes#0001-01-01">https://acloudguru.com/blog/engineering/running-prometheus-on-kubernetes#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p>你想知道如何让普罗米修斯运行在库伯内特？在很大程度上，与普罗米修斯和库伯内特一起工作非常容易。我们将使用一系列YAML文件来部署一切。</p><p><strong>在我们进入技术层面之前，我们有几个假设:</strong></p><ol><li>首先，您已经有了一个Kubernetes堆栈。这篇文章将不包括设置它。</li></ol><p>2.第二，您已经为Kubernetes集群配置了端口<code>9090-9094</code>。否则，您可能需要更改Prometheus服务的目标端口。</p><h2 id="h-create-the-monitoring-namespace"><strong>创建监控名称空间</strong></h2><p>我们将从创建监控名称空间开始。使用您选择的编辑器，创建<code>namespace.yml</code>并添加以下内容:</p><pre class="wp-block-preformatted">{  "kind": "Namespace",  "apiVersion": "v1",  "metadata": {    "name": "monitoring",    "labels": {      "name": "monitoring"    }  }}</pre><p>名称空间在Kubernetes中充当虚拟集群。我们希望确保在监控名称空间中运行所有的Prometheus pods和服务。当您要列出您部署的任何东西时，您将需要使用<code>-n</code>标志并将<code>monitoring</code>定义为名称空间。例如，如果您想列出普罗米修斯舱，您需要执行以下操作:</p><pre class="wp-block-preformatted">kubectl get pods -n monitoring</pre><p><strong>应用名称空间</strong></p><p>现在通过执行<code>kubectl apply</code>命令来应用名称空间:</p><pre class="wp-block-preformatted">kubectl apply -f namespace.yml</pre><p>接下来我们将设置<code>clusterRole.yml</code>。这将用于设置群集的角色。我们需要对此进行设置，以便Prometheus拥有对Kubernetes API的正确权限。</p><p>创建<code>clusterRole.yml</code>文件，并向其中添加以下内容:</p><pre class="wp-block-preformatted">apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRolemetadata:  name: prometheusrules:- apiGroups: [""]  resources:  - nodes  - nodes/proxy  - services  - endpoints  - pods  verbs: ["get", "list", "watch"]- apiGroups:  - extensions  resources:  - ingresses  verbs: ["get", "list", "watch"]- nonResourceURLs: ["/metrics"]  verbs: ["get"]---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  name: prometheusroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: prometheussubjects:- kind: ServiceAccount  name: default  namespace: monitoring</pre><p><strong>应用集群角色</strong>将集群角色应用到Kubernetes集群:</p><pre class="wp-block-preformatted">kubectl apply -f clusterRole.yml</pre><p>我们将使用一个ConfigMap来将任何配置工件从图像内容中分离出来。这将有助于保持容器化应用程序的可移植性。我们将使用它来管理<code>prometheus.yml</code>配置文件。</p><p>创建<code>config-map.yml</code>并添加以下内容:</p><pre class="wp-block-preformatted">apiVersion: v1kind: ConfigMapmetadata:  name: prometheus-server-conf  labels:    name: prometheus-server-conf  namespace: monitoringdata:  prometheus.yml: |-    global:      scrape_interval: 5s      evaluation_interval: 5s    scrape_configs:      - job_name: 'kubernetes-apiservers'        kubernetes_sd_configs:        - role: endpoints        scheme: https        tls_config:          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token        relabel_configs:        - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]          action: keep          regex: default;kubernetes;https      - job_name: 'kubernetes-nodes'        scheme: https        tls_config:          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token        kubernetes_sd_configs:        - role: node        relabel_configs:        - action: labelmap          regex: __meta_kubernetes_node_label_(.+)        - target_label: __address__          replacement: kubernetes.default.svc:443        - source_labels: [__meta_kubernetes_node_name]          regex: (.+)          target_label: __metrics_path__          replacement: /api/v1/nodes/${1}/proxy/metrics      - job_name: 'kubernetes-pods'        kubernetes_sd_configs:        - role: pod        relabel_configs:        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]          action: keep          regex: true        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]          action: replace          target_label: __metrics_path__          regex: (.+)        - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]          action: replace          regex: ([^:]+)(?::d+)?;(d+)          replacement: $1:$2          target_label: __address__        - action: labelmap          regex: __meta_kubernetes_pod_label_(.+)        - source_labels: [__meta_kubernetes_namespace]          action: replace          target_label: kubernetes_namespace        - source_labels: [__meta_kubernetes_pod_name]          action: replace          target_label: kubernetes_pod_name      - job_name: 'kubernetes-cadvisor'        scheme: https        tls_config:          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token        kubernetes_sd_configs:        - role: node        relabel_configs:        - action: labelmap          regex: __meta_kubernetes_node_label_(.+)        - target_label: __address__          replacement: kubernetes.default.svc:443        - source_labels: [__meta_kubernetes_node_name]          regex: (.+)          target_label: __metrics_path__          replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor      - job_name: 'kubernetes-service-endpoints'        kubernetes_sd_configs:        - role: endpoints        relabel_configs:        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]          action: keep          regex: true        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]          action: replace          target_label: __scheme__          regex: (https?)        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]          action: replace          target_label: __metrics_path__          regex: (.+)        - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]          action: replace          target_label: __address__          regex: ([^:]+)(?::d+)?;(d+)          replacement: $1:$2        - action: labelmap          regex: __meta_kubernetes_service_label_(.+)        - source_labels: [__meta_kubernetes_namespace]          action: replace          target_label: kubernetes_namespace        - source_labels: [__meta_kubernetes_service_name]          action: replace          target_label: kubernetes_name</pre><p>这份文件里有很多东西。简而言之，我们使用带有Kubernetes API的服务发现来创建Prometheus目标。这就是为什么我们需要更早地配置集群角色的原因。没有它，Prometheus就没有必要的权限访问API来发现目标。</p><p>正在使用服务发现将以下作业配置为目标。</p><ul><li><code>kubernetes-apiservers</code>:获取Kubernetes APIs的指标。</li><li><code>kubernetes-nodes</code>:获取Kubernetes节点上的指标。</li><li><code>kubernetes-pods</code>:从在元数据中定义了prometheus.io/scrape和prometheus.io/port注释的pod中获取指标。</li><li><code>kubernetes-cadvisor</code>:获取从Kubernetes集群报告的cAdvisor指标。</li><li><code>kubernetes-service-endpoints</code>:从元数据中定义了<code>prometheus.io/scrape</code>和<code>prometheus.io/port</code>注释的服务中获取度量。</li></ul><p>通过使用服务发现，我们不需要在新的pods和服务联机和脱机时用它们来更新<code>prometheus.conf</code>文件。只要在您的pod和服务的元数据中定义了<code>prometheus.io/scrape</code>和<code>prometheus.io/port</code>注释，Prometheus就会自动更新目标。</p><p><strong>应用配置图</strong></p><p>现在应用配置图:</p><pre class="wp-block-preformatted">kubectl apply -f config-map.yml</pre><p>现在配置图已经就绪，我们可以创建Prometheus部署和服务了。</p><p>创建<code>prometheus-deployment.yml</code>并添加以下内容:</p><pre class="wp-block-preformatted">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: prometheus-deployment  namespace: monitoringspec:  replicas: 1  template:    metadata:      labels:        app: prometheus-server    spec:      containers:        - name: prometheus          image: prom/prometheus:v2.2.1          args:            - "--config.file=/etc/prometheus/prometheus.yml"            - "--storage.tsdb.path=/prometheus/"          ports:            - containerPort: 9090          volumeMounts:            - name: prometheus-config-volume              mountPath: /etc/prometheus/            - name: prometheus-storage-volume              mountPath: /prometheus/      volumes:        - name: prometheus-config-volume          configMap:            defaultMode: 420            name: prometheus-server-conf        - name: prometheus-storage-volume          emptyDir: {}---apiVersion: v1kind: Servicemetadata:  name: prometheus-service  namespace: monitoring  annotations:      prometheus.io/scrape: 'true'      prometheus.io/port:   '9090'spec:  selector:    app: prometheus-server  type: NodePort  ports:    - port: 8080      targetPort: 9090      nodePort: 30000</pre><p>有几件事我想指出来。正在创建两个卷装载。</p><p>这些是<code>prometheus-config-volume</code>和<code>prometheus-storage-volume</code>。</p><pre class="wp-block-preformatted">...volumeMounts:            - name: prometheus-config-volume              mountPath: /etc/prometheus/            - name: prometheus-storage-volume              mountPath: /prometheus/...</pre><p><code>prometheus-config-volume</code>将使用我们的配置图来管理<code>prometheus.yml</code>，这反映在volumes部分中。</p><pre class="wp-block-preformatted">...- name: prometheus-config-volume         configMap:           defaultMode: 420           name: prometheus-server-conf...</pre><p>这就是我们如何将<code>prometheus-server-conf</code>配置图用于Prometheus部署。</p><p>对于<code>prometheus-storage-volume</code>，我们正在创建一个空目录来存储普罗米修斯数据。</p><pre class="wp-block-preformatted">...- name: prometheus-storage-volume          emptyDir: {}...</pre><p>这个卷是短暂的，随着Pod一起被创建和销毁。这意味着如果您出于任何原因删除Pod，<code>prometheus-storage-volume</code>中的数据也会随之删除。如果您希望这些数据是持久的，那么您将需要使用一个持久卷。</p><p>现在让我们看看服务中定义的元数据。</p><pre class="wp-block-preformatted">metadata:  name: prometheus-service  namespace: monitoring  annotations:      prometheus.io/scrape: 'true'      prometheus.io/port:   '9090'</pre><p>在这里，我们设置注释，以便普罗米修斯发现该服务，将其作为要清除的目标。要使服务可用，请将<code>prometheus.io/scrape</code>设置为<code>true</code>。然后，您需要确保<code>prometheus.io/port</code>是服务中定义的目标端口。如果不这样，目标就不会被发现。</p><pre class="wp-block-preformatted">ports:    - port: 8080      targetPort: 9090      nodePort: 30000</pre><p>因为目标端口被设置为<code>9090</code>，我们将使用带有<code>prometheus.io/port</code>的端口。</p><pre class="wp-block-preformatted">annotations:      prometheus.io/scrape: 'true'      prometheus.io/port:   '9090'</pre><p>通过执行<code>kubectl apply</code>创建部署和服务。</p><pre class="wp-block-preformatted">kubectl apply -f prometheus-deployment.yml</pre><p>让我们验证pod和服务是否已创建。</p><pre class="wp-block-preformatted">kubectl get pods -n monitoringkubectl get services -n monitoring</pre><p>一旦pod和服务可用，您就可以通过前往<code>https://&lt;KUBERNETES_MASTER_IP&gt;:9090</code>访问Prometheus的表情浏览器。现在，您可以监视部署到集群的pod和服务。</p><h2><strong>关于在Kubernetes上运行Prometheus的更多信息</strong></h2><p>如果你想了解更多关于在Kubernetes上运行Prometheus的信息，可以去看看我的实践课程<a href="https://acloudguru.com/course/monitoring-kubernetes-with-prometheus">用Prometheus </a>监控Kubernetes。快乐监控！</p></div></div>    
</body>
</html>