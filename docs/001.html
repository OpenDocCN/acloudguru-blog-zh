<html>
<head>
<title>How to build a serverless app using Go and Azure Functions | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用Go和Azure功能构建无服务器应用程序</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/how-to-build-a-serverless-app-using-go-and-azure-functions#0001-01-01">https://acloudguru.com/blog/engineering/how-to-build-a-serverless-app-using-go-and-azure-functions#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p>随着<a rel="noreferrer noopener" href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-10498-alvidela" target="_blank"> Azure Functions自定义处理程序</a>的到来，现在没有什么可以阻止你在Azure上使用Go来实现无服务器功能了！下面是一个有趣的方法来尝试自定义处理程序。</p><p>Webhook后端是FaaS(功能即服务)平台的一个流行用例。它们可以用于许多用例，比如发送客户通知或用有趣的gif回复！使用无服务器函数，封装webhook功能并以HTTP端点的形式公开它是非常方便的。</p><p>在本教程中，你将学习如何使用<a href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener"> Azure函数</a>和<a href="https://golang.org/" target="_blank" rel="noreferrer noopener"> Go </a>实现一个<a href="https://api.slack.com/start/overview#apps"> Slack应用</a>作为无服务器后端。您可以扩展Slack平台，并通过实现自定义应用或工作流来集成服务，这些应用或工作流可以访问平台的所有范围，从而让您在Slack中构建强大的体验。</p><p>这是松弛时间的<a href="https://get.slack.help/hc/en-us/articles/204714258-Giphy-for-Slack" target="_blank" rel="noreferrer noopener">图形的一个简单版本。最初的Giphy Slack应用程序通过响应多个gif来响应搜索请求。为了简单起见，本文中演示的函数应用程序只使用</a><a href="https://developers.giphy.com/docs/#operation--gifs-random-get" target="_blank" rel="noreferrer noopener"> Giphy随机API </a>返回一个搜索关键字对应的单个(随机)图像。这篇文章提供了一步一步的指导，让应用程序部署到<a href="https://azure.microsoft.com/en-in/services/functions/?WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener"> Azure Functions </a>，并将其与您的Slack workspace集成。</p><p>在这篇文章中，你将:</p><ul><li>获得Azure函数中自定义处理程序的概述</li><li>通过简短的代码演练了解幕后发生的事情</li><li>了解如何使用配置Azure功能和Slack设置解决方案</li><li>当然，在工作区运行你的Slack应用程序！</li></ul><p>后端功能逻辑用Go编写(代码是GitHub 上可用的<a href="https://github.com/abhirockzz/serverless-go-slack-app/" target="_blank" rel="noreferrer noopener">)。那些使用过Azure函数的人可能还记得，Go是默认支持的语言处理程序中的<em>而不是</em>。这就是</a><a href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener">海关处理员</a>来帮忙的地方！</p><p>简而言之，<a href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers" target="_blank" rel="noreferrer noopener">自定义处理程序</a>是一个轻量级web服务器，它从函数主机接收事件。在您最喜欢的运行时/语言中，您唯一需要实现的定制处理程序就是HTTP支持！这并不意味着定制处理程序仅限于<a href="https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook-trigger?tabs=csharp&amp;WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener"> HTTP触发器</a>。你可以通过扩展包自由使用<a href="https://docs.microsoft.com/azure/azure-functions/functions-triggers-bindings?tabs=csharp&amp;WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener">其他触发器以及输入和输出绑定</a>。</p><p>以下是自定义处理程序工作原理的概要:</p><figure class="wp-block-image size-large"><img loading="lazy" src="../Images/5674fd7e08184329ae06779f66351d4e.png" alt="" class="wp-image-42813" srcset="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1620/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png 1620w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_300/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png 300w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1024/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png 1024w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_768/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png 768w, https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto,w_1536/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png 1536w" sizes="(max-width: 1620px) 100vw, 1620px" data-original-src="https://res.cloudinary.com/acloud-guru/image/fetch/c_thumb,f_auto,q_auto/https://acg-wordpress-content-production.s3.us-west-2.amazonaws.com/app/uploads/2020/12/img2.png"/><figcaption><a href="https://docs.microsoft.com/en-us/azure/azure-functions/media/functions-custom-handlers/azure-functions-custom-handlers-overview.png" target="_blank" rel="noreferrer noopener">https://docs.microsoft.com/en-us/azure/azure-functions/media/functions-custom-handlers/azure-functions-custom-handlers-overview.png</a></figcaption></figure><p>事件触发器(通过HTTP、存储、事件中心等。)调用函数主机。定制处理程序与传统函数的不同之处在于，函数主机充当中间人:它向定制处理程序(函数)的web服务器发出请求有效负载，以及包含触发器、输入绑定数据和函数的其他元数据的<em>有效负载</em>。函数将响应返回给函数宿主，宿主将响应中的数据传递给函数的输出绑定进行处理。</p><p>在我们深入其他领域之前，通过探索代码来理解本质可能会有所帮助，顺便说一下，代码相对简单。</p><p>让我们看看应用程序是如何设置的。</p><pre class="wp-block-preformatted"><br/>├── cmd<br/>│   └── main.go<br/>├── funcy<br/>│   └── function.json<br/>├── go.mod<br/>├── host.json<br/>└── pkg<br/>    └── function<br/>        ├── function.go<br/>        ├── giphy.go<br/>        └── slack.go</pre><p><code>function.json</code>文件位于一个以函数名命名的文件夹中。(<a href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-9656-abhishgu#application-structure" target="_blank" rel="noreferrer noopener">这是惯例</a>。)</p><pre class="wp-block-preformatted">{<br/>    "bindings": [<br/>        {<br/>            "type": "httpTrigger",<br/>            "direction": "in",<br/>            "name": "req",<br/>            "methods": [<br/>                "get",<br/>                "post"<br/>            ]<br/>        },<br/>        {<br/>            "type": "http",<br/>            "direction": "out",<br/>            "name": "res"<br/>        }<br/>    ]<br/>}</pre><p><code>host.json</code>通过指向能够处理HTTP事件的web服务器，告知函数主机向何处发送请求。注意<code>customHandler.description.defaultExecutablePath</code>，它定义了<code>go_funcy</code>是用于运行web服务器的可执行文件的名称。"<code>enableForwardingHttpRequest</code> ": true确保原始HTTP数据不加任何修改地发送到自定义处理程序。</p><pre class="wp-block-preformatted">{<br/>    "version": "2.0",<br/>    "extensionBundle": {<br/>        "id": "Microsoft.Azure.Functions.ExtensionBundle",<br/>        "version": "[1.*, 2.0.0)"<br/>    },<br/>    "customHandler": {<br/>        "description": {<br/>            "defaultExecutablePath": "go_funcy"<br/>        },<br/>        "enableForwardingHttpRequest": true<br/>    },<br/>    "logging": {<br/>        "logLevel": {<br/>            "default": "Trace"<br/>        }<br/>    }<br/>}</pre><p><code>cmd</code>和<code>pkg</code>目录包含Go源代码。让我们在下一小节中探讨这个问题。</p><p><code>cmd/main.go</code>设置并启动HTTP服务器。注意，<code>/api/funcy </code>端点是函数主机向定制处理程序HTTP服务器发送请求的端点。</p><pre class="wp-block-preformatted">func main() {<br/>    port, exists := os.LookupEnv("FUNCTIONS_CUSTOMHANDLER_PORT")<br/>    if !exists {<br/>        port = "8080"<br/>    }<br/>    http.HandleFunc("/api/funcy", function.Funcy)<br/>    log.Fatal(http.ListenAndServe(":"+port, nil))<br/>}</pre><p>所有的重活都在<code>function/function.go</code>完成。</p><p>第一部分是读取请求体(从Slack中)并通过基于Slack 定义的<a href="https://api.slack.com/docs/verifying-requests-from-slack#a_recipe_for_security" target="_blank" rel="noreferrer noopener">这个配方的签名验证过程来确保其完整性。</a></p><pre class="wp-block-preformatted">    signingSecret := os.Getenv("SLACK_SIGNING_SECRET")<br/>    apiKey := os.Getenv("GIPHY_API_KEY")<br/><br/>    if signingSecret == "" || apiKey == "" {<br/>        http.Error(w, "Failed to process request. Please contact the admin", http.StatusUnauthorized)<br/>        return<br/>    }<br/><br/>    slackTimestamp := r.Header.Get("X-Slack-Request-Timestamp")<br/><br/>    b, err := ioutil.ReadAll(r.Body)<br/>    if err != nil {<br/>        http.Error(w, "Failed to process request", http.StatusBadRequest)<br/>        return<br/>    }<br/>    slackSigningBaseString := "v0:" + slackTimestamp + ":" + string(b)<br/>    slackSignature := r.Header.Get("X-Slack-Signature")<br/><br/>    if !matchSignature(slackSignature, signingSecret, slackSigningBaseString) {<br/>        http.Error(w, "Function was not invoked by Slack", http.StatusForbidden)<br/>        return<br/>    }</pre><p>一旦我们确认该函数确实通过Slack被调用，下一步就是提取(Slack)用户输入的搜索词。</p><pre class="wp-block-preformatted">    vals, err := parse(b)<br/>    if err != nil {<br/>        http.Error(w, "Failed to process request", http.StatusBadRequest)<br/>        return<br/>    }<br/>    giphyTag := vals.Get("text")</pre><p>通过调用GIPHY REST API，使用搜索词查找gif。</p><pre class="wp-block-preformatted">    giphyResp, err := http.Get("http://api.giphy.com/v1/gifs/random?tag=" + giphyTag + "&amp;api_key=" + apiKey)<br/>    if err != nil {<br/>        http.Error(w, "Failed to process request", http.StatusFailedDependency)<br/>        return<br/>    }<br/><br/>    resp, err := ioutil.ReadAll(giphyResp.Body)<br/>    if err != nil {<br/>        http.Error(w, "Failed to process request", http.StatusInternalServerError)<br/>        return<br/>    }</pre><p>解编由GIPHY API发回的响应，将其转换成Slack可以理解的形式，并返回它。就是这样！</p><pre class="wp-block-preformatted">    var gr GiphyResponse<br/>    json.Unmarshal(resp, &amp;gr)<br/>    title := gr.Data.Title<br/>    url := gr.Data.Images.Downsized.URL<br/><br/>    slackResponse := SlackResponse{Text: slackResponseStaticText, Attachments: []Attachment{{Text: title, ImageURL: url}}}<br/><br/>    w.Header().Set("Content-Type", "application/json")<br/>    json.NewEncoder(w).Encode(slackResponse)<br/>    fmt.Println("Sent response to Slack")</pre><p>如果您对检查签名验证过程感兴趣，请检查<code>matchSignature</code>函数，并查看slack.go、giphy.go(在<code>function</code>目录中),以了解所使用的go结构表示各个组件之间交换的信息(JSON)。为了保持这篇文章的简洁，这里没有包括这些内容。</p><p>好吧！到目前为止，我们已经介绍了很多理论和背景信息。是时候把事情做好了！在继续之前，请确保满足以下先决条件。</p><p>请记下您的GIPHY API密钥，因为您稍后会用到它</p><p>接下来的章节将引导你完成部署Azure功能和配置Slash命令的Slack的过程。</p><p>首先创建一个<a href="https://docs.microsoft.com/azure/azure-resource-manager/management/manage-resource-groups-portal?WT.mc_id=data-9656-abhishgu" target="_blank" rel="noreferrer noopener">资源组</a>来托管解决方案的所有组件。</p><p>首先在Azure门户搜索<strong>功能App </strong>，点击<strong>添加</strong>。</p><p>输入所需的详细信息:您应该选择<strong>自定义处理程序</strong>作为<strong>运行时堆栈</strong>。</p><p>在<strong>托管</strong>部分，分别为<strong>操作系统</strong>和<strong>计划类型</strong>选择<strong> Linux </strong>和<strong>消费(无服务器)</strong>。</p><p>启用应用洞察(如果需要)。</p><p>查看最终设置并点击<strong>创建</strong>继续。</p><p>该过程完成后，还将创建以下资源和功能应用程序:</p><p>克隆GitHub repo并构建函数。</p><pre class="wp-block-preformatted">git clone https://github.com/abhirockzz/serverless-go-slack-app
cd e-go-slack-app

GOOS=linux go build -o go_funcy cmd/main.go</pre><p><code>GOOS=linux</code>用于构建一个<code>Linux</code>可执行文件，因为我们为我们的函数应用程序选择了一个<code>Linux O</code> S。</p><p>要进行部署，请使用Azure Functions核心工具CLI。</p><pre class="wp-block-preformatted">func azure functionapp publish &lt;enter name of the function app&gt;</pre><p>部署完成后，复制该命令返回的函数URL您将在后续步骤中使用它。</p><p>本节将介绍在工作区中设置Slack应用程序(Slash命令)所需执行的步骤:</p><ul><li>创建一个Slack应用程序</li><li>创建斜线命令</li><li>将应用程序安装到您的工作区</li></ul><p>登录到你的<a href="https://slack.com/signin" target="_blank" rel="noreferrer noopener"> Slack工作空间</a>，并通过<a href="https://api.slack.com/apps/new" target="_blank" rel="noreferrer noopener">创建一个新的Slack应用</a>开始。</p><p>点击<em>创建新命令</em>，用所需信息定义新的<em>斜线命令</em>。请注意，<strong>请求URL </strong>字段是您将输入函数的HTTP端点的字段，它只是您在上一节中部署函数后获得的URL。完成后，点击<strong>保存</strong>完成。</p><p>创建完Slash命令后，转到应用程序的设置页面，在导航菜单中单击<em>基本信息</em>功能，选择<em>将应用程序安装到工作区</em>，然后单击<em>将应用程序安装到工作区</em>——这将把应用程序安装到Slack工作区，以测试应用程序并生成与Slack API交互所需的令牌。一旦你完成应用程序的安装，<em>应用程序凭证</em>就会出现在同一页面上。</p><p>记下您的应用程序<strong>的签名密码</strong>，因为您稍后会用到它。</p><p>…确保更新函数应用配置，以添加松弛签名密钥(<code>SLACK_SIGNING_SECRET</code>)和Giphy API密钥(<code>GIPHY_API_KEY</code> ) —它们将作为函数中的环境变量。</p><p id="h-from-your-slack-workspace-invoke-the-command-funcy-search-term-for-example-try-funcy-dog-you-should-get-back-a-random-gif-in-return">从您的松弛工作区，调用命令<code>/funcy &lt;search term&gt;</code>。(比如试试<code>/funcy dog</code>。)你应该拿回一个随机的GIF作为回报！</p><p>简单回顾一下正在发生的事情:当您在Slack中调用<code>/funcy </code>命令时，它会调用该函数，然后该函数与Giphy API进行交互，最后将GIF返回给用户——假设一切顺利！</p><p>第一次调用后，您可能会从Slack中看到<code>timeout error</code>。这很可能是由于第一次调用<code>cold start</code>时，该函数需要几秒钟来引导。再加上<a href="https://api.slack.com/slash-commands#responding_basic_receipt" target="_blank" rel="noreferrer noopener"> Slack期望在3秒内得到响应</a>——因此出现了错误消息。</p><p>没什么好担心的。你需要做的就是再次尝试，一切都会好的！</p><p>清理:一旦完成，别忘了<a href="https://docs.microsoft.com/azure/azure-resource-manager/management/delete-resource-group?tabs=azure-powershell&amp;WT.mc_id=data-9656-abhishgu#delete-resource-group" target="_blank" rel="noreferrer noopener">删除资源组</a>，这又会删除之前创建的所有资源(功能app，App服务计划等。)</p><p>现在，没有什么可以阻止你在Azure上使用Go实现无服务器功能！我希望这将是一种尝试定制处理程序的有趣方式。让我们知道你的想法。</p><h4 id="h-about-the-author">关于作者</h4><p>Abhishek Gupta是微软的高级开发人员。你可以在<a href="https://twitter.com/abhi_tweeter?opt_id=oeu1596472260634r0.19676524222612213" target="_blank" rel="noreferrer noopener"> Twitter </a>上关注他，在<a href="https://in.linkedin.com/in/abhirockzz?opt_id=oeu1596472260634r0.19676524222612213" target="_blank" rel="noreferrer noopener"> LinkedIn </a>上联系他，或者关注他的<a href="https://medium.com/@abhishek1987?opt_id=oeu1596472260634r0.19676524222612213" target="_blank" rel="noreferrer noopener">博客</a>。</p></div></div>    
</body>
</html>