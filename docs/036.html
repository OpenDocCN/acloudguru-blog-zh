<html>
<head>
<title>The Story of Python 2 and 3 | A Cloud Guru</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python 2和3的故事|云专家</h1>
<blockquote>原文：<a href="https://acloudguru.com/blog/engineering/the-story-of-python-2-and-3#0001-01-01">https://acloudguru.com/blog/engineering/the-story-of-python-2-and-3#0001-01-01</a></blockquote><div><div class="elementor-widget-container"><p>我们为系统管理员开设了<a target="_blank" rel="noopener noreferrer" href="https://linuxacademy.com/linux/training/course/name/python-scripting-for-system-administrators" noreferrer="1"> Python脚本课程，该课程涉及Python 2和Python 3。这次发布是讨论<em>为什么</em>这个版本差异如此重要以及你应该注意什么的好时机。</a></p><h2 id="a-brief-aside-on-versioning">关于版本控制的简短说明</h2><p>如果你利用<a target="_blank" rel="noopener noreferrer" href="https://semver.org/" noreferrer="1"> SemVer </a>对一个软件项目进行版本控制，那么一个主要的版本变更就是做出“突破性变更”的时候了，这就是Python 3所做的。从版本控制的角度来看，这正是我们应该如何对我们的项目进行版本控制。</p><h2 id="mistakes-were-made">犯了错误…</h2><p>Python 3之所以存在，是因为Guido看到了该语言需要一些改进的地方，而这些改变不能在考虑向后兼容性的情况下进行。作为一个从事软件工作的人，你可以边做边学，在开始的时候，你几乎不可能知道所有的事情。一个项目的设计会经历一些后来发现不尽如人意的转折，这很有道理。Python 3是偿还“技术债务”的一个很好的例子，但是这个决定最初并没有被很好地接受。在Python 3发布的时候，有很多Python代码在生产，既有开源的也有专有的。可以想象，当您需要潜在地更改应用程序代码的大部分时，在您的业务中升级到新版本的语言是很困难的。这是Python 3面临的问题，所以即使Python 3很棒，也很难在一夜之间移动这么大的社区。</p><h2 id="key-differences">主要差异</h2><p>以下是我认为最有可能影响Python代码的两个主要版本之间的差异:</p><h3 id="strings-binary-data-bytes">字符串和二进制数据(字节)</h3><p>在版本2中，您可以将Unicode数据(字节)与8位字符串混合使用，这种方法偶尔会有效，但并不总是有效。这导致了Python 3中的变化；您不再能够隐式地混合文本和二进制数据。根据文件的模式，最有可能出错的地方是与文件内容的交互。这里有一个例子，可以演示同样的代码如何在Python 2和3之间产生不同的类型和错误。<em> str_vs_bytes.py </em></p><div id="cb1" class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><a id="cb1-1" class="sourceLine"/>f <span class="op">=</span> <span class="bu">open</span>(<span class="st">"example.txt"</span>, <span class="st">'rb'</span>) <span class="co"># opening in 'binary' read mode</span><a id="cb1-2" class="sourceLine"/><a id="cb1-3" class="sourceLine"/>data <span class="op">=</span> f.read()<a id="cb1-4" class="sourceLine"/>other_str <span class="op">=</span> <span class="st">"other string"</span><a id="cb1-5" class="sourceLine"/><a id="cb1-6" class="sourceLine"/><span class="bu">print</span>(<span class="st">"data is of type: </span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> <span class="bu">type</span>(data))<a id="cb1-7" class="sourceLine"/><span class="bu">print</span>(<span class="st">"other_str is of type: </span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> <span class="bu">type</span>(other_str))<a id="cb1-8" class="sourceLine"/><a id="cb1-9" class="sourceLine"/>data <span class="op">+</span> other_str <span class="co"># concatenating to see if an error occurs</span></code></pre></div><p>如果我们用Python 2运行这个脚本，我们会得到以下结果:</p><pre><code>$ python2 str_vs_bytes.pydata is of type: &lt;type 'str'&gt;other_str is of type: &lt;type 'str'&gt;</code></pre><p>用Python 3做同样的事情，我们会看到一个错误，并且<code>other_str</code>与<code>data</code>的类型不同:</p><pre><code>$ python3 str_vs_bytes.pydata is of type: &lt;class 'bytes'&gt;other_str is of type: &lt;class 'str'&gt;Traceback (most recent call last):  File "str_vs_bytes.py", line 9, in &lt;module&gt;    data + other_strTypeError: can't concat str to bytes</code></pre><p>这里最大的障碍是确保在Python 3中总是以正确的模式打开文件。</p><h3 id="print-statement-vs-print-function"><code>print</code>语句与<code>print</code>函数</h3><p>编程中最常见的事情之一是打印到屏幕上。Python通过使用Python 2中的<code>print</code> <em>语句</em>和Python 3中的<code>print</code> <em>函数</em>，使打印变得尽可能简单。这种差别非常微妙，但是在Python 2和3之间，<code>print</code>的使用发生了变化，它是一个函数，因此需要括号。这一行在Python 2中运行得非常好，但是在Python 3中会引发一个异常:<em> Python 2 </em></p><pre><code>&gt;&gt;&gt; print "something"something</code></pre><p><em> Python 3 </em></p><pre><code>&gt;&gt;&gt; print "something"  File "&lt;stdin&gt;", line 1    print "something"                    ^SyntaxError: Missing parentheses in call to 'print'. Did you mean print("something")?</code></pre><p>幸运的是，这个错误很好地解释了这种情况，如果您在Python 2 <code>print</code>的用法中添加括号，就不会遇到任何问题。</p><h3 id="integer-division">整数除法</h3><p>在Python 2中，2个整数的除法总是返回一个整数。这是有意义的，因为你可能不想隐式地从<code>int</code>转换到<code>float</code>，但是作为一个程序员，当你想到除法时，你只想做普通的数学运算。这种行为在Python 3中有所改变，因此标准除法将返回完整的结果，而不是截断的值。<em> Python 2 </em></p><div id="cb6" class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><a id="cb6-1" class="sourceLine"/><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">//</span> <span class="dv">2</span><a id="cb6-2" class="sourceLine"/><span class="va">True</span><a id="cb6-3" class="sourceLine"/><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span><a id="cb6-4" class="sourceLine"/><span class="dv">0</span></code></pre></div><p>下面是使用<em> Python 3 </em>的同一个例子:</p><div id="cb7" class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><a id="cb7-1" class="sourceLine"/><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">//</span> <span class="dv">2</span><a id="cb7-2" class="sourceLine"/><span class="va">False</span><a id="cb7-3" class="sourceLine"/><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">2</span><a id="cb7-4" class="sourceLine"/><span class="fl">0.5</span></code></pre></div><h2 id="writing-code-for-python-2-3">为Python编写代码2<strong>&amp;3</strong></h2><p>在<a href="https://linuxacademy.com/linux/training/course/name/python-scripting-for-system-administrators" target="_blank" rel="noopener noreferrer">课程</a>中，我们利用测试驱动开发(TDD)来帮助我们设计软件，但我们得到的一个额外好处是我们有一个测试套件，可以针对多个版本的Python运行。这种方法使你更容易确信你正在编写支持两个主要版本的软件，但是如果你没有编写测试，那么你知道主要的区别是很重要的。</p></div></div>    
</body>
</html>